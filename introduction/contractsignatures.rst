################################################################################
Контракты с подписью
################################################################################

При формировании транзакции с контрактом, мы всегда имеем подпись отправившего лица. Эта подпись автоматически поверяется при разборе транзакции. Кроме этого, имеются функция **CallContract** и возможность вызова контракта в виде **ContractName(parameters)**. Разберем такую ситуацию, пусть имеется контракт перевода денег *send_money*.

.. code:: js

  contract send_money {
      data {
        Recipient int
        Amount    money
      }
      ...
  }
  
Если мы в каком-то контракте вызовем его как *send_money("Recipient,Amount", 12345, 777)*, то у нас будет осуществлен перевод 777 монет на кошелек 12345. Проблема в том, что пользователь подписывающий первичный контракт мог быть вообще не курсе, что с него будут списаны деньги. Предположим, мы хотим сделать так, чтобы контракт send_money требовал дополнительной подписи пользователя при вызове из других контрактов. Что для этого нужно сделать?

1. Нужно добавить в *send_money* поле с именем **Signature** и опциями *optional* и *hidden*. Эти опции позволят не требовать дополнительной подписи при вызове контракта напрямую, так как там уже будет подпись.

.. code:: js

  contract send_money {
      data {
        Recipient int
        Amount    money
        Signature string "optional hidden"
      }
      ...
  }
  
2. Нужно добавить в таблицу **Signatures** запись с именем нашего контракта *send_money*. Также там мы указываем текст, который будет показываться при подтверждении и указываем пары значений. В качестве параметра указываем имена полей, значения которыx будут показываться пользователю, а в качестве текста указываем понятное имя для данного параметра. Необязательно добавлять туда все поля, которые есть в контракте, но в нашем случае у нас всего два важных поля, поэтому укажем оба. Например, мы можем указать следующее:

**Title**: Are you agree to send money this recipient?

**Parameter**: Receipient       **Text**: Wallet ID

**Parameter**: Amount           **Text**: Amount (qEGS)

Этих двух шагов достаточно, чтобы защитить наш контракт от несанкционированных вызовов из других контрактов. Если вставить вызов *send_money("Recipient,Amount",123466,12)*, то мы получим ошибку *Signature is not defined*. Если мы вызовем так *send_money("Recipient,Amount,Signature",123466,12,"xxx...xxxxx")*, то мы получим ошибку при проверке подписи, так как нам не подделать подпись пользователя. При отправке будут подписываться следующие данные: *"время оригинальной транзакции,id пользователя,значение полей указанных в таблице signatures"*. Соответственно при вызове контракта будет проверяться подпись этих данных.

Теперь рассмотрим, что нужно сделать, чтобы пользователь увидел при отправке нашего контракта подтверждение на перевод денег и контракт смог без проблем вызвать *send_money* с подписанными данными. Для этого в наш контракт необходимо добавить поле с типом *string* и дополнительной опцией **signature:contractname**. Имя поля может быть любое. И при вызове необходимо просто передать этот параметр. Также следует иметь в виду, что параметры для вызова защищенного контракта должны также присутствовать в нашем контракте, Они могут быть скрытые, но они все равно будут отображаться при подтверждении. Например,

.. code:: js

  contract MyTest {
    data {
        Recipient int "hidden"
        Amount    money
        Signature string "signature:send_money"
    }
    func action {
         send_money("Recipient,Amount,Signature",$Recipient,$Amount,$Signature)
    }
  }

В данном случае, при отправке контракта *MyTest*, у пользователя будет запрошено дополнительное подтверждение для перевода определенной суммы на определенный кошелек. Если мы в контракте попытаемся указать другие параметры *send_money("Recipient,Amount,Signature",$Recipient,$Amount+10,$Signature)*, то получим ошибку, что подпись неверна.




