################################################################################
REST API v2
################################################################################

Черновик команд API v2 для работы с EGAAS. Для работы с REST API v2 необходимо скомпилировать сервер из ветки **gorm_arch**. Графического интерфейса для API v2 в браузере нет.

Вызов команды происходит при обращении к **/api/v2/command/[param]**, где **command** - имя команды, **param** - дополнительный параметр, например, имя изменяемого или получаемого ресурса. Отправлять параметры запросов следует с **Content-Type: x-www-form-urlencoded**. Ответ сервера представлен в JSON формате.

********************************************************************************
Обработка ошибок
********************************************************************************

В случае успешного выполнения запроса возвращается статус 200. В случае ошибки, кроме ошибочного статуса возвращается объект JSON c полями:

* **error** - идентификатор ошибки. 
* **msg** - текст ошибки. 
* **params** - массив дополнительных параметров ошибки, которые могут быть подставлены в сообщение об ошибке.

Пример ответа

.. code:: 

    400 (Bad Request)
    Content-Type: application/json
    {
        "err": "E_INVALIDWALLET",
        "msg": "Wallet 1111-2222-3333 is not valid",
        "params": ["1111-2222-3333"]
    }

Список ошибок

* **E_CONTRACT** - There is not %s contract
* **E_DBNIL** - DB is nil
* **E_ECOSYSTEM** - Ecosystem %d doesn't exist
* **E_EMPTYPUBLIC** - Public key is undefined
* **E_EMPTYSIGN** - Signature is undefined
* **E_HASHWRONG** - Hash is incorrect
* **E_HASHNOTFOUND** - Hash has not been found
* **E_INSTALLED** - Apla is already installed
* **E_INVALIDWALLET** - Wallet %s is not valid
* **E_NOTFOUND** - Content page or menu has not been found
* **E_NOTINSTALLED** - Apla is not installed. В этом случае нужно запустить установку командно *install*.
* **E_QUERY** - DB query is wrong
* **E_RECOVERED** - API recovered. Возвращается в случае panic error.
* **E_REFRESHTOKEN** - Refresh token is not valid
* **E_SERVER** - Server error. Возвращается в случае ошибки в библиотечных функциях golang. Поле *msg* содержит текст ошибки.
* **E_SIGNATURE** - Signature is incorrect
* **E_STATELOGIN** - %s is not a membership of ecosystem %s
* **E_TABLENOTFOUND** - Table %s has not been found
* **E_TOKEN** - Token is not valid
* **E_UNAUTHORIZED** - Unauthorized
* **E_UNDEFINEVAL** - Value %s is undefined
* **E_UNKNOWNUID** - Unknown uid

Если, неважно где, возвращается ошибка **E_RECOVERED**, то это баг, который требует обнаружения и исправления. Ошибка **E_NOTINSTALLED** должна возвращаться любой командой кроме install, в случае, если система еще не установлена. Ошибка **E_SERVER** теоретически может возвратится в любой команде. Если она возникает на неверных входных параметрах, то её можно заменить на соответствующие ошибки. В противном случае, это ошибка сообщает о неверном функционировании или настройке системы, то есть требует более детального изучения. Ошибка **E_UNAUTHORIZED** может возвращаться на любой команде кроме *install, getuid, login* в случае, если не был осуществлен login или сессия закончилась.

********************************************************************************
Аутентификация
********************************************************************************

Для аутентификации используется **JWT токен** http://www.jwt.org. После получения JWT токена необхоимо передавать его при каждом запросе в заголовке: **Authorization: Bearer TOKEN_HERE**. 

getuid
==============================
**GET** Возвращает уникальное значение, которое нужно подписать своим приватным ключом и отправить обратно серверу с помощью команды **login**. На данный момент создается временный JWT токен, который нужно передать в **Authorization** при вызове **login**.

.. code:: 
    
    GET
    /api/v2/getuid
    
Ответ

* *uid* - строка для подписи.
* *token* - временный токен для передачи в login. Время жиззни временного токена сейчсас составляет 5 секунд.

В случае, когда авторизация не требуется, то возвращаются

* *expire* - количество секунд до истечения срока. 
* *state* - идентификатор экосистемы.
* *wallet* - идентификатор  кошелька.
* *address* - адрес кошелька в формате XXXX-XXXX-.....-XXXX.
    
Вариант ответа

.. code:: 
    
    200 (OK)
    Content-Type: application/json
    {
        "uid": "28726874268427424",
        "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6I........AU3yPRp64SLO4aJqhN-kMoU5HNYTDplQXbVu0Y"
    }
    
Ошибки: *E_SERVER*   

login
==============================
**POST** Аутентификация пользователя. Предварительно необходимо вызвать команду **getuid** для получения уникального значения и подписать его. В заголовке нужно передать временный JWT токен полученный вместе с getuid. В случае успешного завершения нужно полученный в ответе токен передавать во всех запросах в заголовке *Authorization*.

Запрос

.. code:: 

    POST
    /api/v2/login
    
* *[state]* - идентификатор экосистемы. Если не указан, то берется первая экосистема.
* *[expire]* - время длительности JWT токена в секундах. По умолчанию, 36000.
* *[pubkey]* - публичный ключ hex. Если в блокчейне уже есть хранится ключ, то нужно передать номер кошелька в любом виде в параметре *wallet*. 
* *[wallet]* - кошелек в виде числа или XXXX-...-XXXX. Использовать, если публичный ключ уже хранится в блокчейне. Нельзя указывать совместно с *pubkey*.
* *signature* - подпись uid полученного через getuid hex.

Ответ

* *token* - JWT токен.
* *refresh* - JWT токен для продления сессии. Необходимо передавать в команду **refresh**.
* *state* - идентификатор экосистемы.
* *wallet* - идентификатор  кошелька.
* *address* - адрес кошелька в формате XXXX-XXXX-.....-XXXX.
* *notify_key* - ключ для получения уведомлений.

Вариант ответа

.. code:: 
    
    200 (OK)
    Content-Type: application/json
    {
        "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6I........AU3yPRp64SLO4aJqhN-kMoU5HNYT8fNGODp0Y"
        "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6I........iOiI1Nzk3ODE3NjYwNDM2ODA5MzQ2Iiw"        
        "state":"1",
        "wallet":"12345",
        "address": "1234-....-3424"
    }      

Ошибки: *E_SERVER, E_UNKNOWNUID, E_SIGNATURE, E_STATELOGIN, E_EMPTYPUBLIC* 

refresh
==============================
**POST** Команда выдает новые токены и продляет сессию пользователя. В случае успешного завершения нужно полученный в ответе токен передавать во всех запросах в заголовке *Authorization*.

Запрос

.. code:: 

    POST
    /api/v2/refresh
    
* *[expire]* - время длительности JWT токена в секундах. По умолчанию, 36000.
* *token* - токен обновления из предыдущего вызова **login** или **refresh**.

Ответ

* *token* - JWT токен.
* *refresh* - JWT токен для продления сессии. Необходимо передавать в команду **refresh**.

Вариант ответа

.. code:: 
    
    200 (OK)
    Content-Type: application/json
    {
        "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6I........AU3yPRp64SLO4aJqhN-kMoU5HNYT8fNGODplQXbVu0Y"
        "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6I........iOiI1Nzk3ODE3NjYwNDM2ODA5MzQ2Iiw"        
    }      

Ошибки: *E_SERVER, E_TOKEN, E_REFRESHTOKEN* 

signtest
==============================
**POST** Команда подписывает строку указанным приватным ключом. Должна использоваться исключительно для тестирования API, так как в реальной работе приватный ключ не должен передаваться на сервер. Приватный ключ можно взять из директории где запускается сервер.

.. code:: 
    
    POST
    /api/v2/signtest
 
* *private* - hex приватный ключ
* *forsign* - строка для подписи

Ответ

* *signature* - подпись в шестнадцатеричном виде
* *pubkey* - публичный ключ для переданного приватного ключа hex.
    
Вариант ответа

.. code:: 
    
    200 (OK)
    Content-Type: application/json
    {
        "signature": "0011fa...",
        "pubkey": "324bd7..."
    }      

Ошибки: *E_SERVER* 

********************************************************************************
Служебные команды
********************************************************************************

install
==============================
**POST** Команда производит установку системы. После успешной установки систему требуется перезапустить. 

Запрос

.. code:: 

    POST
    /api/v2/install
 
* *type* - тип установки: **PRIVATE_NET, TESTNET_NODE, TESTNET_URL**.
* *log_level* - уровень логгирования: **ERROR, DEBUG**.
* *first_load_blockchain_url* - адрес для получения блокчейна. Указывается в случае *type* равным *TESTNET_URL*.
* *db_host* - хост для БД PostgreSQL. Например, *localhost*
* *db_port* - порт для БД PostgreSQL. Например, *5432*
* *db_name* - имя БД PostgreSQL. Например, *mydb*
* *db_user* - имя пользователя для подключения к БД PostgreSQL. Например, *postgres*
* *db_pass* - пароль для подключения к БД PostgreSQL. Например, *postgres*
* *generate_first_block* - Может быть равен 0 или 1 когда *type* равен *Private-net*. 
* *first_block_dir* - директория где хранится файл *1block* с первым блоком. Указывается когда *generate_first_block* равен 0     и *type* равен *PRIVATE_NET*.

Ответ

* *success* - true в случае успешного завершения.

Вариант ответа

.. code:: 
    
    200 (OK)
    Content-Type: application/json
    {
        "success": true
    }      

Ошибки: *E_SERVER, E_INSTALLED, E_DBNIL* 

********************************************************************************
Функции получения данных
********************************************************************************

balance
==============================
**GET** Получить баланс указанного кошелька в текущей экосистеме. 

Запрос

.. code:: 
    
    GET
    /api/v2/balance/{wallet}
    
* *wallet* - Номер кошелька. Может быть представлен в любом формате - int64, uint64, XXXX-...-XXXX. Поиск указанного кошелька осуществляется в экосистеме, в которую вошел пользователь.   
    
Ответ    

* *amount* - cумма в кошельке в минимальных единицах (например, в qAPLA).
* *money* - cумма в кошельке в единицах (например, в APLA).
    
Вариант ответа

.. code:: 
    
    200 (OK)
    Content-Type: application/json
    {
        "amount": "123450000000000000000",
        "money": "123.45"
    }      

********************************************************************************
Работа с экосистемами
********************************************************************************

ecosystems
==============================
**GET** Возвращает количество экосистем.

.. code:: 
    
    GET
    /api/v2/ecosystems/

Ответ

* *number* - количество установленных экосистем.
    
Вариант ответа

.. code:: 
    
    200 (OK)
    Content-Type: application/json
    {
        "number": 100,
    }      

ecosystemparams
==============================
**GET** Возвращает список параметров экосистемы. 

Запрос

.. code:: 
    
    GET
    /api/v2/ecosystemparams/[?ecosystem=...&names=...]

* *[ecosystem]* - идентификатор экосистемы. Если не указан, то будут возвращены параметры текущей экосистемы.
* *[names]* - список получаемых параметров. При желании можно указать через запятую список имен получаемых параметров. Например, */api/v2/ecosystemparams/?names=name,currency,logo*.


Ответ 

* *list* - массив, каждый элемент которого содержит следующие параметры.

  * *name* - наименование параметра.
  * *value* - значение параметра.
  * *conditions* - условие изменения параметра

Вариант ответа

.. code:: 
    
    200 (OK)
    Content-Type: application/json
    {
        "list": [{ 
            "name": "name",
            "value": "MyState",
            "conditions": "true",
        }, 
        { 
            "name": "currency",
            "value": "MY",
            "conditions": "true",
        }, 
        ]
    }      

Ошибки: *E_ECOSYSTEM*

ecosystemparam/{name}
==============================
**GET** Получить информацию о параметре с именем **{name}** в текущей или указанной экосистеме. 

Запрос

.. code:: 
    
    GET
    /api/v2/ecosystemparam/{name}[?ecosystem=1]
    
* *name* - имя запрашиваемого параметра.
* *[ecosystem]* - можно указать идентификатор экосистемы. По умолчанию, возвратится значение текущей экосистемы.

Ответ
    
* *name* - наименование параметра.
* *value* - значение параметра.
* *conditions* - условие изменения параметра    
    
Вариант ответа

.. code:: 
    
    200 (OK)
    Content-Type: application/json
    {
        "name": "currency",
        "value": "MYCUR",
        "conditions": "true"
    }      

Ошибки: *E_ECOSYSTEM*
    
tables/[?limit=...&offset=...]
==============================
**GET** Возвращает список таблиц в текущей экосистеме. Можно указать смещение и количество запрашиваемых таблицы. 

Запрос

* *[limit]* - количество записей. По умолчанию, 25.
* *[offset]* - смещение начала записей. По умолчанию, 0.


.. code:: 
    
    GET
    /api/v2/tables

Ответ

* *count* - общее количество записей в таблице.
* *list* - массив, каждый элемент которого содержит следующие параметры.

  * *name* - наименование таблицы. Имя таблицы возвращается без префикса.
  * *count* - количество записей в таблице.

Вариант ответа

.. code:: 
    
    200 (OK)
    Content-Type: application/json
    {
        "count": "100"
        "list": [{ 
            "name": "accounts",
            "count": "10",
        }, 
        { 
            "name": "citizens",
            "count": "5",
       }, 
        ]
    }    

table/{name}
==============================
**GET** Возвращает информацию о таблице с указанным именем в текущей экосистеме.

Для получения информации о глобальной таблице необходимо добавить параметр global. Возвращаются следующие поля: "name" - имя таблицы, "insert" - права на вставку элементов, "new_column" - права на добавление клонки, "general_update": права на изменени прав, "columns" - массив колонок с полями *name, type, perm* - имя, тип, права на изменение.

Запрос

.. code:: 
    
    GET
    /api/v2/table/mytable
    
* *name* - имя таблицы (без префикса-идентифкатора экосистемы).

Ответ

* *name* - имя таблицы (без префикса-идентифкатора экосистемы).
* *insert* - условие на добавление записей.
* *new_column* - условие на добавление колонки.
* *update* - условие на изменение записей.
* *conditions* - условие на изменение настроек таблицы.
* *columns* - массив информации о колонках.

  * *name* - имя столбца.
  * *type* - тип колонки. Возможны следующие значения: **varchar,bytea,number,money,text,double,character**.
  * *perm* - Условие на изменения записе в столбце.
    
Вариант ответа

.. code:: 
    
    200 (OK)
    Content-Type: application/json
    {
        "name": "mytable",
        "insert": "ContractConditions(`MainCondition`)",
        "new_column": "ContractConditions(`MainCondition`)",
        "update": "ContractConditions(`MainCondition`)",
        "conditions": "ContractConditions(`MainCondition`)",
        "columns": [{"name": "mynum", "type": "number", "perm":"ContractConditions(`MainCondition`)" }, 
            {"name": "mytext", "type": "text", "perm":"ContractConditions(`MainCondition`)" }
        ]
    }      
    
Ошибки: *E_TABLENOTFOUND*    
    
list/{name}[?limit=...&offset=...&columns=]
==============================
**GET** Возвращает список записей указанной таблицы в текущей экосистеме. Можно указать смещение и количество запрашиваемых элементов таблицы. 

Запрос

* *name* - имя таблицы.
* *[limit]* - количество записей. По умолчанию, 25.
* *[offset]* - смещение начала записей. По умолчанию, 0.
* *[columns]* - список запрашиваемых колонок через запятую. Если не указано, то будут возвращены все колонки. Колонка id возвращается в любом случае.

.. code:: 
    
    GET
    /api/v2/list/mytable?columns=name

Ответ

* *count* - общее количество записей в таблице.
* *list* - массив, каждый элемент которого содержит следующие параметры.

  * *id* - идентификатор записи.
  * последовательность запрошенных колонок. 

Вариант ответа

.. code:: 
    
    200 (OK)
    Content-Type: application/json
    {
        "count": "10"
        "list": [{ 
            "id": "1",
            "name": "John",
        }, 
        { 
            "id": "2",
            "name": "Mark",
       }, 
        ]
    }   

row/{tablename}/{id}[?columns=]
==============================
**GET** Возвращает запись таблицы с указанным id в текущей экосистеме. Можно указать возвращаемые колонки. 

Запрос

* *tablename* - имя таблицы.
* *id* - идентификатор записи.
* *[columns]* - список запрашиваемых колонок через запятую. Если не указано, то будут возвращены все колонки. Колонка id возвращается в любом случае.

.. code:: 
    
    GET
    /api/v2/row/mytable/10?columns=name

Ответ

* *value* - массив полученных значений колонок.

  * *id* - идентификатор записи.
  * последовательность запрошенных колонок. 

Вариант ответа

.. code:: 
    
    200 (OK)
    Content-Type: application/json
    {
        "values": {
        "id": "10",
        "name": "John",
        }
    }   

********************************************************************************
Функции работы с контрактами
********************************************************************************

contract/{name}
==============================
**GET** Получить информацию о смарт конракте с именем **{name}**. По умолчанию, смарт контракт ищется в текущей экосистеме.

Запрос

* *name* - имя смарт контракта.

.. code:: 
    
    GET
    /api/v2/contract/mycontract

Ответ

* *name* - имя смарт контракта с идентификатором экосистемы. Например, *@{idecosystem}name.
* *active* - true если контракт активирован и false в противном случае.
* *tableid* - идентификатор записи в таблице contracts, где хранится исходный код данного контракта.
* *fields* -  массив, содержащий информацию о каждом параметре в разделе **data** контракта и содержит поля:

  * *name* - имя поля.
  * *htmltype* - html тип.
  * *type* - тип парметра.
  * *tags* - тэги параметра.
    
Вариант ответа

.. code:: 
    
    200 (OK)
    Content-Type: application/json
    {
        "fields" : [
            {"name":"amount", "htmltype":"textinput", "type":"int64", "tags": "optional"},
            {"name":"name", "htmltype":"textinput", "type":"string" "tags": ""}
        ],
        "name": "@1mycontract",
        "tableid" : 10,
        "active": true
    }      

contract/{name}
==============================
**POST** Вызвать смарт контракт с указанным именем **{name}**. Предварительно нужно вызывать команду **prepare/{name}** (POST) и подписывать возвращаемое поле *forsign*. В случае успешного выполнения возвращается хэш транзакции, c помощью которого можно получить номер блока в случае успешного выполнения или текст ошибки.

Запрос

* *name* - имя вызываемого контракта. Если контракт вызывается из другой эклсистемы, то необходимо указывать полное имя с идентификатором экосистемы (*@1MainContract*).
* *[token_ecosystem]* - для неактивированных контрактов можно указать валютой какой экосистемы будет оплачен контракт. В этом случае аккаунт и публичный ключ *token_ecosystem* и текущей экосистемы должны совпадать.
* *[max_sum]* - при вызове неактивированных контрактов можно указать максимальную сумму, которую согласны потратить на выполнение данного контракта.
* *[payover]* - для неактивированных контрактов можно указать надбавку за срочность - сколько добавить к fuel_rate при вычислении оплаты.
* параметры, необходимые для данного контракта.
* *signature* - hex подпись значения *forsign*, которое получено из prepare.
* *time* - время, возвращенное prepare.
* *pubkey* - hex публичный ключ подписавшего контракт. Следует заметить, что если публичный ключ уже хранится в таблице keys данной экосистемы, то его можно не передавать.

.. code:: 
 
    POST
    /api/v2/contract/mycontract
    signature - hex подпись
    time - время, возвращенное prepare

Ответ

* *hash* - hex хэш отправленной транзакции.

Вариант ответа

.. code:: 

    200 (OK)
    Content-Type: application/json
    {
        "hash" : "67afbc435634.....",
    }


prepare/{name}
==============================
**POST** Отправляет запрос на получение строки для подписи указанного контракта. В качестве **{name}** необходимо указать имя транзакции для которой следует возвратить строку для подписи. В параметре forsign возвращается строка, которую необходимо будет подписать. Также возвращается параметр time, который нужно будет передать вместе с подписью. 

Запрос

* *name* - имя контракта. Если вызывается контракт из другой экосистемы, то необходимо указывать полное имя (*@1MainContract*).
* *[token_ecosystem]* - для неактивированных контрактов можно указать валютой какой экосистемы будет оплачен контракт. В этом случае аккаунт и публичный ключ *token_ecosystem* и текущей экосистемы должны совпадать.
* *[max_sum]* - при вызове неактивированных контрактов можно указать максимальную сумму, которую согласны потратить на выполнение данного контракта.
* *[payover]* - для неактивированных контрактов можно указать надбавку за срочность - сколько добавить к fuel_rate при вычислении оплаты.
* параметры, необходимые для данного контракта.

.. code:: 
    
    POST
    /api/v2/prepare/mycontract

Ответ

* *forsign* - строка для подписи.
* *time* - время, которое нужно будет передать вместе с контрактом.

Вариант ответа

.. code:: 
    
    200 (OK)
    Content-Type: application/json
    {
        "time": 423523768,
        "forsign": "......", 
    }      
    
txstatus/{hash}
==============================
**GET** Возвращает номер блока или ошибку отправленной транзакции с данным хэшем. Если возвращаемые значения *blockid* и *errmsg* пустые, значит транзакция еще не была запечатана в блок.

Запрос

* *hash* - хэш проверяемой транзакции.

.. code:: 
    
    GET
    /api/v2/txstatus/2353467abcd7436ef47438
    
Ответ

* *blockid* - номер блока, в случае успешной обработки транзакции.
* *result* - результат работы транзакции, возвращаемый через переменную **$result**.
* *errmsg* - текст ошибки, в случае отклонения транзакции.
    
Вариант ответа

.. code:: 
    
    200 (OK)
    Content-Type: application/json
    {
        "blockid": "4235237",
        "result": ""
    }      
    

content/{menu|page}/{name}
==============================
**POST** Возвращает JSON представление кода указанной страницы или меню с именем **{name}**, которое получается после обработки шаблонизатором. При запросе можно передавать дополнительные параметры, которые можно использовать в шаблонизаторе. Если страница или меню не найдены, то возвращается ошибка 404.

.. code:: 
    
    GET
    /api/v2/content/page/default

Ответ

* *menu* - имя меню для страницы.
* *tree* - JSON дерево объектов.

Вариант ответа

.. code:: 
    
    200 (OK)
    Content-Type: application/json
    {
        "tree": {"type":"......", 
              "children": [
                   {...},
                   {...}
              ]
        },
    }      

Ошибки: *E_NOTFOUND*
