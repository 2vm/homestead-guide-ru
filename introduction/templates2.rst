################################################################################
Шаблонизатор страниц v2
################################################################################
********************************************************************************
Отличия от первой версии
********************************************************************************
В связи с переходом общения интерфейсной части только посредством API и выделения интерфейса на новую платформу (**React**) потребовалось изменить результат работы шаблонизатора. Также в новой версии нужно было учесть пожелания и замечания, который возникли при работе с первой версией шаблонизатора. 
В отличии от первой версии, вторая версия шаблонизатора выдает не готовую HTML страницу, а промежуточное дерево, которое представляет собой HTML тэги расположенные в виде дерева в соответствии с тем, как они описаны в шаблонизаторе. Для получения этого дерева для страниц и меню необходимо использовать команду content из API v2. Кроме этого, для тестирования, можно отправлять POST запрос в **api/v2/content** c параметром *template*, который содержит шаблон для обработки.
Следует заметить, что в новой версии мы отказались от двух типров функций () и {} и оставили только вызовы (), но кроме этого для всех вызовов сделали возможность указывать параметры по их именам. Об этом подробнее будет написано ниже. Сам список функций тоже будет переработан.

********************************************************************************
Общее описание шаблонизатора
********************************************************************************
Типы функций
==============================
Шаблоны страниц приложений создаются с помощью набора функций, который можно рассматривать как специализированный язык для создания интерфейсов приложений APLA. Функции можно разделить на несколько групп по типу выполняемых операций:

* получение значений из базы данных;
* оперирование с форматами и значениями переменных;
* представление данных в виде таблиц и диаграмм;
* построение форм с необходимым набором полей для ввода данных контрактов;
* вывод элементов навигации и вызова контрактов;
* создание элементов HTML разметки страницы – различных контейнеров с возможностью указания css классов;
* реализация условного вывода фрагментов шаблонов страниц; 
* создание многоуровневого меню.

Общее описание языка шаблонизатора
==============================
Язык построения шаблонов страниц по сути явяляется функциональным языком, где вы вызывает функции в виде FuncName(parameters) и причем функции могут вкладываться друг в друга. Параметры можно не заключать в кавычки. Если параметр не нужен, то его можно никак не обозначать.

.. code:: js

      Text MyFunc(parameter number 1, parameter number 2) another text.
      MyFunc(parameter 1,,,parameter 4)

Если параметр содержит запятую, то тогда его нужно заключить в обратные или двойные кавычки. При этом, если параметр у функции возможен только один, то в нем можно использовать запятые не обрамляя его в кавычки.  Также кавычки нужно использовать если в параметре имеется непарная закрывающая скобка.

.. code:: js

      MyFunc("parameter number 1, the second part of first paremeter")
      MyFunc(`parameter number 1, the second part of first paremeter`)

Если вы заключили параметр в кавычки, но там также используются кавычки, то можно использовать разные кавычки или дублировать их в тексте.

.. code:: js

      MyFunc("parameter number 1, ""the second part of first"" paremeter")
      MyFunc(`parameter number 1, "the second part of first" paremeter`)

При описании функций каждый параметр имеет определенное имя. Вы можете вызывать функции и указывать параметры в том порядке как они описаны, а можете явно указывать только нужные параметры по их именам в любом порядке как **Имя_параметра: Значение_параметра**. Такой подход позволяет безболезненно добавлять новые параметры в функции без нарушения совместимости с текущими шаблонами. Например, пусть у нас есть функция, которая описана как **MyFunc(Class,Value,Body)**, то все эти вызовы будут корректными с точки зрения языка.

.. code:: js

      MyFunc(myclass, This is value, Div(divclass, This is paragraph.))
      MyFunc(Body: Div(divclass, This is paragraph.))
      MyFunc(myclass, Body: Div(divclass, This is paragraph.))
      MyFunc(Value: This is value, Body: 
           Div(divclass, This is paragraph.)
      )
      MyFunc(myclass, Value without Body)
      
Некоторые функции возвращают просто текст, некоторые создают HTML элемент (например, *Input*), а некоторые функцию создают HTML элемент с вложенными HTML элементами (*Div, P, Span*). В последнем случае для определения вложенных элементов используется параметр с предопределенным именем **Body**. Например, два *div*, вложенные в другой *div*, могут выглядеть так:

.. code:: js

      Div(Body:
         Div(class1, This is the first div.)
         Div(class2, This is the second div.)
      )
      
Для указания вложенных элементов, которые описываются в параметре *Body* можно использовать слежующее представление: **MyFunc(...){...}**, где в фигурных скобках указываются вложенные элементы. 

.. code:: js

      Div(){
         Div(class1){
            P(This is the first div.)
            Div(class2){
                Span(This is the second div.)
            }
         }
      }
      
Если идет подряд несколько одинаковых функции, то вместо имен второй и следующих можно ставить только точку. Например, следующие две строчки эквивалентны

.. code:: js

     Span(Item 1)Span(Item 2)Span(Item 3)
     Span(Item 1).(Item 2).(Item 3)
     
В языке можно присваивать переменные с помощью функции **SetVar**. Для подстановки значений переменных используется запись **#varname#**.

.. code:: js

     SetVar(name, My Name)
     Span(Your name: #name#)

Для подстановки языковых ресурсов экосистемы можно использовать запись **$langres$**, где *langres* имя языкового ресурса.
.. code:: js

     Span($yourname$: #name#)

********************************************************************************
Возвращаемое значение
********************************************************************************

Результирующее JSON дерево состоит из объектов **Node** со следующими параметрами:

* *tag* String - имя HTML элемента или специального объекта.
* *attr* Object - объект состоящий из пар ключ - значение передаваемых атрибутов. Как правило сюда попадают все параметры, с именами в нижнем регистре. Например, **class, value, id**.
* *text* String - обычный текст. В этом случае, *tag* равен **text**. 
* *children* Array - массив вложенных объектов *Node*. Сюда попадают все элементы, описанные в параметре **Body**.     

********************************************************************************
Функции
********************************************************************************

Address(Wallet)
==========================
Функция возвращает адрес кошелька в формате 1234-5678-...-7990 по числовому значению адреса; если адрес не указан, то в качестве аргумента принимается значение адреса текущего пользователя. 

.. code:: js

      Span(Your wallet: Address(#wallet#))
      
And(parameters)
==========================
Функция возвращает результат выполнения логической операции **И** со всеми перечисленными в скобках через запятую параметрами. Значение параметра принимается как **false**, если он равен пустой строке (""), 0 или *false*. Во всех остальных случаях значение параметра считается **true**. Соответственно функция возвращает 1 в случае истины и в противном случае 0. Элемент с именем **and** создается только при запросе дерева для редактирования. 

.. code:: js

      If(And(#myval1#,#myval2#), Span(OK))


Button(Body, Page, Class, Contract, Params, PageParams) [.Alert(Text,ConfirmButton,CancelButton,Icon)]
==========================
Создает HTML элемент **button**. Этот элемент должен создавать кнопку, которая будет отправлять на выполнение указанный контракт.

* *Body* - дочерний текст или элементы.
* *Page* - название страницы для перехода.
* *Class* - классы для данной кнопки.
* *Contract* - Имя вызываемого контракта.
* *Params* - список передаваемых в контракт значений. По умолчанию, значения параметров контракта (секция data) берутся из HTML элементов (скажем, полей формы) с одноименными идентификаторами (id). Если идентификаторы элементов отличаются от названий параметров контракта, то используется присваивание в формате *contractField1=idname1, contractField2=idname2*. Данный параметр возвращается в *attr* в виде объекта *{field1: idname1, field2: idname2}*.
**ПРИМЕЧАНИЕ** В случае, когда Inputs не указан, то реализация на фронтенде может брать все контролы в form, где находится кнопка или самостоятельно запрашивать из API список параметров и брать значения *input* c такими же идентификаторами.
* *PageParams* - параметры для перехода на страницу.

**Alert** - указывается для вывода сообщений.

* *Text* - текст сообщения.
* *ConfirmButton* - текст кнопки подтверждения.
* *CancelButton* - текст кнопки отмены.
* *Icon* - иконка.

.. code:: js

      Button(Submit, default_page, mybtn_class).Alert(Alert message)
      Button(Contract: MyContract, Body:My Contract, Class: myclass, Params:"Name=myid,Id=i10,Value")

DBFind(Name) [.Columns(columns)] [.Where(conditions)] [.WhereId(id)] [.Order(name)] [.Limit(limit)] [.Offset(offset)] [.Ecosystem(id)]
==========================
Создает элемент **data** и возвращает данные из таблицы базы данных. В *attr* возвращаются два массива - *columns* c именами колонок и *data* с записями. Последоавтельность в именах колонок соответствует последовательности значений в записях в *data*.

* *Name* - имя таблицы.

* **Columns** - список возвращаемых колонок. Если не указано, то возвратятся все колонки. 
* **Where** - условие поиска. Например, *.Where(name = '#myval#')*
* **WhereId** - условие поиска по идентификатору. Достаточно указать значение идентификатора.  Например, *.WhereId(1)*
* **Order** - поле, по которому нужно отсортировать. 
* **Limit** - количество возвращаемыхх записей. По умолчанию, 25. Максимально возможно количество - 250.
* **Offset** - смещение возвращаемых записей.
* **Ecosystem** - идентификатор экосистемы. По умолчанию, берутся данные из таблицы в текущей экосистеме.

.. code:: js

    DBFind(parameters)
    DBFind(parameters).Columns(name,value).Where(name='money')

Div(Class, Body)
==========================
Создает HTML элемент **div**.

* *Class* - классы для данного *div*.
* *Body* - дочерние элементы.

.. code:: js

      Div(class1 class2, This is a paragraph.)

Em(Body, Class)
==========================
Создает HTML элемент **em**.

* *Body* - дочерний текст или элементы.
* *Class* - классы для данного *em*.

.. code:: js

      This is an Em(important news).

Form(Class, Body)
==========================
Создает HTML элемент **form**.

* *Class* - классы для данного *form*.
* *Body* - дочерние элементы.

.. code:: js

      Form(class1 class2, Input(myid))
      
GetVar(Name)
==========================
Функция возвращает значение указанной переменной, если она существует, и возвращает пустую строку, если переменная с данным именем не определена. Элемент с именем **getvar** создается только при запросе дерева для редактирования. Отличие *GetVar(varname)* от использования *#varname#* состоит в том, что если *varname* не существует, то *GetVar* возвратит пустую строку, а *#varname#* так и останется.

* *Name* - имя переменной.

.. code:: js

     If(GetVar(name)){#name#}.Else{Name is unknown}
      
If(Condition){ Body } [.ElseIf(Condition){ Body }] [.Else{ Body }]
==========================
Условный оператор. Возвращаются дочерние элементы первого *If* или *ElseIf* у которого выполнено условие *Condition*. В противном случае, возвращаются дочерние элементы *Else*, если он присутствует.

* *Condition* - Условие. Считается не выполненным если равно *пустой строке*, *0* или *false*. В остальных случаях, условие считается истинным.
* *Body* - дочерние элементы.

.. code:: js

      If(#value#){
         Span(Value)
      }.ElseIf(#value2#){Span(Value 2)
      }.ElseIf(#value3#){Span(Value 3)}.Else{
         Span(Nothing)
      }
      
Include(Name)
==========================
Команда вставляет шаблон с именем *Name* из таблицы *blocks*. При вставке происходит разбор шаблона и происходит вставка разобранных элементов.

* *Name* - Имя вставляемого шаблона из таблицы *blocks*.

.. code:: js

      Div(myclass, Include(mywidget))

Input(Name,Class,Placeholder,Type,Value) [.Validate(validation parameters)]
==========================
Создает HTML элемент **input**.

* *Name* - имя элемента.
* *Class* - классы для данного *input*.
* *Placeholder* - *placeholder* для данного *input*.
* *Type* - типа для данного *input*.
* *Value* - значение элемента.

**Validate** - параметры валидации.

.. code:: js

      Input(Name: name, Type: text, Placeholder: Enter your name)
      Input(Name: num, Type: text).Validate(minLength: 6, maxLength: 20)

InputErr(Name,validation errors)]
==========================
Создает элемент **inputerr** c текстами для ошибок валидации.

* *Name* - имя соответствующего элемента **Input**.

.. code:: js

      InputErr(Name: name, 
          minLength: Value is too short, 
          maxLength: The length of the value must be less than 20 characters)

Label(Body, Class, For)
==========================
Создает HTML элемент **label**.

* *Body* - дочерний текст или элементы.
* *Class* - классы для данного *label*.
* *For* - значение *for* для данного *label*.

.. code:: js

      Label(The first item).
      
LangRes(Name, Lang)
==========================
Возвращает указанный языковой ресурс. В случае запроса дерева для редактирования возвращается элемент **langres**.

* *Name* - имя языкового ресурса.
* *Lang* - по умолчанию, возвращается язык который определен в запросе в *Accept-Language*. При желании вы можете указать свой двухсивольный идентификатор языка.

.. code:: js

      LangRes(name)
      LangRes(myres, fr)

MenuGroup(Title, Body, Icon) 
==============================
Функция формирует в меню вложенное подменю и возвращает элемент **menugroup**. 

* *Title* - имя пункта меню.
* *Body* - дочерние элементы подменю;
* *Icon* - иконка.

.. code:: js

      MenuGroup(My Menu){
          MenuItem(Interface, sys-interface)
          MenuItem(Dahsboard, dashboard_default)
      }

MenuItem(Title, Page, Params, Icon) 
==============================
Служит для создания пункта меню и возвращает элемент **menuitem**. 

* *Title* - имя пункта меню;
* *Page* - имя страницы перехода.;
* *Params* - параметры, передаваемые странице в формате *var:value* через запятую.
* *Icon* - иконка.

.. code:: js

       MenuItem(Interface, interface)

Or(parameters)
==========================
Функция возвращает результат выполнения логической операции **ИЛИ** со всеми перечисленными в скобках через запятую параметрами. Значение параметра принимается как **false**, если он равен пустой строке (""), 0 или *false*. Во всех остальных случаях значение параметра считается **true**. Соответственно функция возвращает 1 в случае истины и в противном случае 0. Элемент с именем **or** создается только при запросе дерева для редактирования. 

.. code:: js

      If(Or(#myval1#,#myval2#), Span(OK))

P(Body, Class)
==========================
Создает HTML элемент **p**.

* *Body* - дочерний текст или элементы.
* *Class* - классы для данного *p*.

.. code:: js

      P(This is the first line.
        This is the second line.)

SetVar(Name, Value)
==========================
Присваивает переменной с именем *Name* значение *Value*. Элемент с именем **setvar** создается только при запросе дерева для редактирования.

* *Name* - имя переменной.
* *Value* - значение переменной, может содержать ссылку на другие переменные.

.. code:: js

     SetVar(name, John Smith).(out, I am #name#)
     Span(#out#)

Span(Body, Class)
==========================
Создает HTML элемент **span**.

* *Body* - дочерний текст или элементы.
* *Class* - классы для данного *span*.

.. code:: js

      This is Span(the first item, myclass1).

Strong(Body, Class)
==========================
Создает HTML элемент **strong**.

* *Body* - дочерний текст или элементы.
* *Class* - классы для данного *strong*.

.. code:: js

      This is Strong(the first item, myclass1).

Style(Css)
==========================
Функция служит для добавления своих CSS стиле и создает элемент **style**.

* *Css* - описание стилей.

.. code:: js

      Style(.mydiv, .myspan {
		color: #f00;
		margin: 10px 5px;
	})
