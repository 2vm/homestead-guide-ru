################################################################################
Шаблонизатор страниц v2
################################################################################
********************************************************************************
Отличия от первой версии
********************************************************************************
В связи с переходом общения интерфейсной части только посредством API и выделения интерфейса на новую платформу (**React**) потребовалось изменить результат работы шаблонизатора. Также в новой версии нужно было учесть пожелания и замечания, который возникли при работе с первой версией шаблонизатора. 
В отличии от первой версии, вторая версия шаблонизатора выдает не готовую HTML страницу, а промежуточное дерево, которое представляет собой HTML тэги расположенные в виде дерева в соответствии с тем, как они описаны в шаблонизаторе. Для получения этого дерева для страниц и меню необходимо использовать команду content из API v2. Кроме этого, для тестирования, можно отправлять POST запрос в **api/v2/content** c параметром *template*, который содержит шаблон для обработки.
Следует заметить, что в новой версии мы отказались от двух типров функций () и {} и оставили только вызовы (), но кроме этого для всех вызовов сделали возможность указывать параметры по их именам. Об этом подробнее будет написано ниже. Сам список функций тоже будет переработан.

********************************************************************************
Общее описание шаблонизатора
********************************************************************************
Типы функций
==============================
Шаблоны страниц приложений создаются с помощью набора функций, который можно рассматривать как специализированный язык для создания интерфейсов приложений APLA. Функции можно разделить на несколько групп по типу выполняемых операций:

* получение значений из базы данных;
* оперирование с форматами и значениями переменных;
* представление данных в виде таблиц и диаграмм;
* построение форм с необходимым набором полей для ввода данных контрактов;
* вывод элементов навигации и вызова контрактов;
* создание элементов HTML разметки страницы – различных контейнеров с возможностью указания css классов;
* реализация условного вывода фрагментов шаблонов страниц; 
* создание многоуровневого меню.

Форматы функций
==============================
Язык построения шаблонов страниц по сути явяляется функциональным языком, где вы вызывает функции в виде FuncName(parameters) и причем функции могут вкладываться друг в друга. Параметры можно не заключать в кавычки. Если параметр не нужен, то его можно никак не обозначать.

.. code:: js

      Text MyFunc(parameter number 1, parameter number 2) another text.
      MyFunc(parameter 1,,,parameter 4)

Если параметр содержит запятую, то тогда его нужно заключить в обратные или двойные кавычки. Также кавычки нужно использовать если в параметре имеется непарная закрывающая скобка.

.. code:: js

      MyFunc("parameter number 1, the second part of first paremeter")
      MyFunc(`parameter number 1, the second part of first paremeter`)

Если вы заключили параметр в кавычки, но там также используются кавычки, то можно использовать разные кавычки или дублировать их в тексте.

.. code:: js

      MyFunc("parameter number 1, ""the second part of first"" paremeter")
      MyFunc(`parameter number 1, "the second part of first" paremeter`)

При описании функций каждый параметр имеет определенное имя. Вы можете вызывать функции и указывать параметры в том порядке как они описаны, а можете явно указывать только нужные параметры по их именам в любом порядке как **Имя_параметра: Значение_параметра**. Такой подход позволяет безболезненно добавлять новые параметры в функции без нарушения совместимости с текущими шаблонами. Например, пусть у нас есть функция, которая описана как **MyFunc(Class,Value,Body)**, то все эти вызовы будут корректными с точки зрения языка.

.. code:: js

      MyFunc(myclass, This is value, Div(divclass, This is paragraph.))
      MyFunc(Body: Div(divclass, This is paragraph.))
      MyFunc(myclass, Body: Div(divclass, This is paragraph.))
      MyFunc(Value: This is value, Body: 
           Div(divclass, This is paragraph.)
      )
      MyFunc(myclass, Value without Body)
      
Некоторые функции возвращают просто текст, некоторые создают HTML элемент (например, *Input*), а некоторые функцию создают HTML элемент с вложенными HTML элементами (*Div, P, Span*). В последнем случае для определения вложенных элементов используется параметр с предопределенным именем **Body**. Например, два *div*, вложенные в другой *div*, могут выглядеть так:

.. code:: js

      Div(Body:
         Div(class1, This is the first div.)
         Div(class2, This is the second div.)
      )
      
Для указания вложенных элементов, которые описываются в параметре *Body* можно использовать слежующее представление: **MyFunc(...){...}**, где в фигурных скобках указываются вложенные элементы. 

.. code:: js

      Div(){
         Div(class1){
            P(This is the first div.)
            Div(class2){
                Span(This is the second div.)
            }
         }
      }

********************************************************************************
Возвращаемое значение
********************************************************************************

Результирующее JSON дерево состоит из объектов **Node** со следующими параметрами:

* *tag* String - имя HTML элемента или специального объекта.
* *attr* Object - объект состоящий из пар ключ - значение передаваемых атрибутов. Как правило сюда попадают все параметры, с именами в нижнем регистре. Например, **class, value, id**.
* *text* String - обычный текст. В этом случае, *tag* равен **text**. 
* *children* Array - массив вложенных объектов *Node*. Сюда попадают все элементы, описанные в параметре **Body**.     

********************************************************************************
Функции
********************************************************************************

Div(Class, Body)
==========================
Создает HTML элемент **div**.

* *Class* - классы для данного *div*.
* *Body* - дочерние элементы.

.. code:: js

      Div(class1 class2, This is a paragraph.)

Button(Body, Page, Class, Contract, Params, PageParams)[.Alert(Text,ConfirmButton,CancelButton,Icon)]
==========================
Создает HTML элемент **button**. Этот элемент должен создавать кнопку, которая будет отправлять на выполнение указанный контракт.

* *Body* - дочерний текст или элементы.
* *Page* - название страницы для перехода.
* *Class* - классы для данной кнопки.
* *Contract* - Имя вызываемого контракта.
* *Params* - список передаваемых в контракт значений. По умолчанию, значения параметров контракта (секция data) берутся из HTML элементов (скажем, полей формы) с одноименными идентификаторами (id). Если идентификаторы элементов отличаются от названий параметров контракта, то используется присваивание в формате *contractField1=idname1, contractField2=idname2*. Данный параметр возвращается в *attr* в виде объекта *{field1: idname1, field2: idname2}*.
**ПРИМЕЧАНИЕ** В случае, когда Inputs не указан, то реализация на фронтенде может брать все контролы в form, где находится кнопка или самостоятельно запрашивать из API список параметров и брать значения *input* c такими же идентификаторами.
* *PageParams* - параметры для перехода на страницу.

**Alert** - указывается для вывода сообщений.

* *Text* - текст сообщения.
* *ConfirmButton* - текст кнопки подтверждения.
* *CancelButton* - текст кнопки отмены.
* *Icon* - иконка.

.. code:: js

      Button(Submit, default_page, mybtn_class).Alert(Alert message)
      Button(Contract: MyContract, Body:My Contract, Class: myclass, Params:"Name=myid,Id=i10,Value")

Em(Body, Class)
==========================
Создает HTML элемент **em**.

* *Body* - дочерний текст или элементы.
* *Class* - классы для данного *em*.

.. code:: js

      This is an Em(important news).

Form(Class, Body)
==========================
Создает HTML элемент **form**.

* *Class* - классы для данного *form*.
* *Body* - дочерние элементы.

.. code:: js

      Form(class1 class2, Input(myid))
      
If(Condition){ Body }[.ElseIf(Condition){ Body }][.Else{ Body }]
==========================
Условный оператор. Возвращаются дочерние элементы первого *If* или *ElseIf* у которого выполнено условие *Condition*. В противном случае, возвращаются дочерние элементы *Else*, если он присутствует.

* *Condition* - Условие. Считается не выполненным если равно *пустой строке*, *0* или *false*. В остальных случаях, условие считается истинным.
* *Body* - дочерние элементы.

.. code:: js

      If(#value#){
         Span(Value)
      }.ElseIf(#value2#){Span(Value 2)
      }.ElseIf(#value3#){Span(Value 3)}.Else{
         Span(Nothing)
      }

Input(Name,Class,Placeholder,Type,Value)[.Validate(validation parameters)]
==========================
Создает HTML элемент **input**.

* *Name* - имя элемента.
* *Class* - классы для данного *input*.
* *Placeholder* - *placeholder* для данного *input*.
* *Type* - типа для данного *input*.
* *Value* - значение элемента.

**Validate** - параметры валидации.

.. code:: js

      Input(Id: name, Type: text, Placeholder: Enter your name)
      Input(Id: num, Type: text).Validate(minLength: 6, maxLength: 20)

Label(Body, Class, For)
==========================
Создает HTML элемент **label**.

* *Body* - дочерний текст или элементы.
* *Class* - классы для данного *label*.
* *For* - значение *for* для данного *label*.

.. code:: js

      Label(The first item).

P(Body, Class)
==========================
Создает HTML элемент **p**.

* *Body* - дочерний текст или элементы.
* *Class* - классы для данного *p*.

.. code:: js

      P(This is the first line.
        This is the second line.)

Span(Body, Class)
==========================
Создает HTML элемент **span**.

* *Body* - дочерний текст или элементы.
* *Class* - классы для данного *span*.

.. code:: js

      This is Span(the first item, myclass1).

Strong(Body, Class)
==========================
Создает HTML элемент **strong**.

* *Body* - дочерний текст или элементы.
* *Class* - классы для данного *strong*.

.. code:: js

      This is Strong(the first item, myclass1).
