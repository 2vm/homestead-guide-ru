################################################################################
Интерфейсы пользователя
################################################################################

.. contents::
  :local:
  :depth: 2
 
********************************************************************************
Построение интерфейсов
********************************************************************************
Программный клиента Molis, реализованый на *библиотеке JavaScript React*, содержит редактор и визуальный конструктор интерфейсов. Страницы интерфейса являются неотъемлемой частью приложений и обеспечивают получение и отображение данных из таблиц базы данных, создание форм для получения данных от пользователя, передачу данных в контракт, а так же навигацию между страницами приложений. Страницы как и контракты хранятся в блокчейне, что обеспечивает возможность контроля их нефальсифицированности при загрузке их в программном клиенте.  

Шаблонизатор интерфейсов
==============================
Элементы интерфейса (страницы и меню) формируются в так называемом *шаблонизаторе* из шаблонов, написанных программистами в редакторе интерфесов программного клиента Molis на специально разработанном командой Apla функциональном языке Protypo. Интерфейсы запрашиваются у  узлов сети командой *content* API. Шблонизатор посылает не готовую HTML страницу, а JSON код, который представляет собой HTML тэги, расположенные в виде дерева в соответствии со структурой шаблона. Для тестирования, можно отправлять POST запрос в ``api/v2/content`` c параметром *template*, который содержит шаблон для обработки.

Создание шаблонов интерфейсов
==============================
Интерфейсы создаются и редактируются в специальном редакторе секции **Interface** административного раздела Molis. Редактор обеспечивает:

- написание кода интерфейсных страниц с подсветкой ключевых слов языка шаблонизатора Protypo,
- выбор меню, которое будет отображаться на странице,
- переход к редактированию привязанного меню,
- задание прав на редактированию страницы (традиционно через указание имени контракта с определенными в нем правами в специальной функции *ContractConditions* или прямым указанием условий доступа в поле *Change conditions*),
- вызов визуального редактора,
- переход к просмотру страницы.

Визуальный конструктор интерфейсов позволяет создавать дизайн страниц без обращения к коду на языке Protypo. В конструкторе методом drag and drop настраиваются положение элементов форм и текста, размеры и стилевое оформление блоков страницы. В конструкторе имеется набор готовых блоков для отображения типовых моделей данных: панели с заголовками, формы, информационные панели. Программная логика (получение данных, условные конструкции) вводится в стандартном редакторе страниц после создания дизайна. (В дальнейшем планируется реализовать полнофункциональный визуальный редактор интерфейсов.)

По умолчанию страницы интерфейса отображаются с использование классов Angular Bootstrap Angle. При необходимости можно создавать собственные стили, для хранения которых используется специальный параметр настроечной таблицы экосистемы stylesheet. 

Для использования на множестве страниц типового фрагмента кода имеется возможность создавать страничные блоки и встраивать их в код интерфейса с помощью команды *Insert*. Создаются и редактируются блоки на странице *Interface* административной секции Molis. Для блоков как и для страниц задаются права на редактирование.

Программный клиент Molis содержит механизм локализации интерфейса: специальная функция языка  шаблонизатора LangRes подставляет в текст страницы вместо языкового ресурса (лейбла) его перевод на язык установленный в программном клиенте (или в браузере для web-версии клиента). Вместо функции LangRes возможно использование сокращенного синтаксиса  $lable$. Перевод сообщений во всплывающих окнах, инициируемых контрактами, выполняется функцией LangRes, имеющейся  в языке Simvolio.

Ввод и редактирование языковых ресурсов осуществляется в специальном разделе Language resources административной секции программного клиента Molis. При создании языкового ресурса задается его лейбла  (имя) и необходимое число переводов с указанием двухсимвольного  идентификатора языка (en, fr и др.).

Права на добавление и изменения языковых ресурсов настраиваются стандартными для таблиц методами в таблице languages (раздел Tables административной секции Molis). 

********************************************************************************
Язык шаблонизатора Protypo
********************************************************************************

Функции Protypo обеспечивают выполнение следующих операций:

- получение значений из базы данных: DBFind;
- представление данных полученных и базы данных в виде таблиц и диаграмм;
- присваивание и вывод значений переменных, оперирование с данными;
- вывод и сравнение значений времени и даты;
- построение форм с необходимым набором полей для ввода данных пользователя;
- валидация данных в полях формы с выводом сообщений об ошибках;
- вывод элементов навигации;
- вызов контрактов;
- создание элементов HTML разметки страницы – различных контейнеров с возможностью указания css классов;
- встраивание изображения в страницу и загрузку изображения;
- условный вывод фрагментов шаблонов страниц: ``If, ElseIf, Else``;
- создание многоуровневого меню;
- локализация интерфейсов.

Общее описание языка Protypo
==============================
Язык построения шаблонов страниц по сути является функциональным языком, где вы вызывает функции в виде ``FuncName(parameters)`` и причем функции могут вкладываться друг в друга. Параметры можно не заключать в кавычки. Если параметр не нужен, то его можно никак не обозначать.

.. code:: js

      Text MyFunc(parameter number 1, parameter number 2) another text.
      MyFunc(parameter 1,,,parameter 4)

Если параметр содержит запятую, то тогда его нужно заключить в обратные или двойные кавычки. При этом, если параметр у функции возможен только один, то в нем можно использовать запятые не обрамляя его в кавычки.  Также кавычки нужно использовать если в параметре имеется непарная закрывающая скобка.

.. code:: js

      MyFunc("parameter number 1, the second part of first paremeter")
      MyFunc(`parameter number 1, the second part of first paremeter`)

Если вы заключили параметр в кавычки, но там также используются кавычки, то можно использовать разные кавычки или дублировать их в тексте.

.. code:: js

      MyFunc("parameter number 1, ""the second part of first"" paremeter")
      MyFunc(`parameter number 1, "the second part of first" paremeter`)

При описании функций каждый параметр имеет определенное имя. Вы можете вызывать функции и указывать параметры в том порядке как они описаны, а можете явно указывать только нужные параметры по их именам в любом порядке как ``Имя_параметра: Значение_параметра``. Такой подход позволяет безболезненно добавлять новые параметры в функции без нарушения совместимости с текущими шаблонами. Например, пусть у нас есть функция, которая описана как ``MyFunc(Class,Value,Body)``, то все эти вызовы будут корректными с точки зрения языка.

.. code:: js

      MyFunc(myclass, This is value, Div(divclass, This is paragraph.))
      MyFunc(Body: Div(divclass, This is paragraph.))
      MyFunc(myclass, Body: Div(divclass, This is paragraph.))
      MyFunc(Value: This is value, Body: 
           Div(divclass, This is paragraph.)
      )
      MyFunc(myclass, Value without Body)
      
Некоторые функции возвращают просто текст, некоторые создают HTML элемент (например, *Input*), а некоторые функцию создают HTML элемент с вложенными HTML элементами (``Div, P, Span``). В последнем случае для определения вложенных элементов используется параметр с предопределенным именем **Body**. Например, два *div*, вложенные в другой *div*, могут выглядеть так:

.. code:: js

      Div(Body:
         Div(class1, This is the first div.)
         Div(class2, This is the second div.)
      )
      
Для указания вложенных элементов, которые описываются в параметре *Body* можно использовать слежующее представление: ``MyFunc(...){...}``, где в фигурных скобках указываются вложенные элементы. 

.. code:: js

      Div(){
         Div(class1){
            P(This is the first div.)
            Div(class2){
                Span(This is the second div.)
            }
         }
      }
      
Если идет подряд несколько одинаковых функции, то вместо имен второй и следующих можно ставить только точку. Например, следующие две строчки эквивалентны

.. code:: js

     Span(Item 1)Span(Item 2)Span(Item 3)
     Span(Item 1).(Item 2).(Item 3)
     
В языке можно присваивать переменные с помощью функции **SetVar**. Для подстановки значений переменных используется запись **#varname#**.

.. code:: js

     SetVar(name, My Name)
     Span(Your name: #name#)

Для подстановки языковых ресурсов экосистемы можно использовать запись **$langres$**, где *langres* имя языкового ресурса.

.. code:: js

     Span($yourname$: #name#)
     
Существуют следующие предопределенные переменные:

* **#key_id#** - идентификатор-аккаунта текущего пользователя.
* **#ecosystem_id#** - идентификатор текущей экосистемы.

Передача параметров странице через PageParams
==========================
Есть ряд функций, которые принимают параметр **PageParams**. Он служит для передачи параметров при переходе на новую страницу. Например, ``PageParams: "param1=value1,param2=value2"``. В качестве значения параметров могут быть как обычные строки, так и строки с подстановкой значений переменных. 

* ``PageParams: "hello=world"`` - страница получит параметр hello со значением world
* ``PageParams: "hello=#world#"`` - страница получит параметр hello со значением переменной world

Кроме этого, существует функция **Val**, которая позволяет получать данные из форм, которые были указаны на момент перехода. В этом случае,

* ``PageParams: "hello=Val(world)"`` - страница получит параметр hello со значением элемента формы с именем world


Возвращаемое значение
==========================
Результирующее JSON дерево состоит из объектов **Node** со следующими параметрами:

* *tag* String - имя HTML элемента или специального объекта.
* *attr* Object - объект состоящий из пар ключ - значение передаваемых атрибутов. Как правило сюда попадают все параметры, с именами в нижнем регистре. Например, **class, value, id**.
* *text* String - обычный текст. В этом случае, *tag* равен **text**. 
* *children* Array - массив вложенных объектов *Node*. Сюда попадают все элементы, описанные в параметре **Body**.

Вызов контрактов
==========================
Вызов контрактов Protypo происходит при клике на кнопке  формы (функция *Button*). При этом производится передача в контракт данных, введенных пользователем в поля формы (если имена полей формы и имена переменных в секции data вызываемого контракта совпадают, то данные передаются автоматически). В функции Button возможен вызова модального окна для подтверждения пользователем запуска контракта (Alert), а так же инициация перехода на указанную страницу после успешного выполнения контракта с передачей странице перечисленных параметров.

********************************************************************************
Функции Protypo
********************************************************************************

Address(account)
==========================
Функция возвращает адрес аккаунта в формате 1234-5678-...-7990 по числовому значению адреса; если адрес не указан, то в качестве аргумента принимается значение адреса текущего владельца аккаунта. 

.. code:: js

      Span(Your wallet: Address(#account#))

AddToolButton(Title, Icon, Page, PageParams)
==========================
Добавляет кнопку в панель инструментов. Создает элемент **addtoolbutton**. 

* *Title* - заголовок кнопки,
* *Icon* - иконка для кнопки,
* *Page* - имя страницы для перехода,
* *PageParams* - параметры, передаваемые странице.

.. code:: js

      AddToolButton(Help, help, help_page)

And(parameters)
==========================
Функция возвращает результат выполнения логической операции **И** со всеми перечисленными в скобках через запятую параметрами. Значение параметра принимается как **false**, если он равен пустой строке (""), 0 или *false*. Во всех остальных случаях значение параметра считается **true**. Соответственно функция возвращает 1 в случае истины и в противном случае 0. Элемент с именем **and** создается только при запросе дерева для редактирования. 

.. code:: js

      If(And(#myval1#,#myval2#), Span(OK))


Button(Body, Page, Class, Contract, Params, PageParams) [.Alert(Text,ConfirmButton,CancelButton,Icon)] [.Style(Style)]
==========================
Создает элемент HTML-формы  **button**, по клику на котором инициируется выполнение контракта или переход на другую страницу.

* *Body* - дочерний текст или элементы,
* *Page* - имя страницы для перехода,
* *Class* - классы для данной кнопки,
* *Contract* - имя вызываемого контракта,
* *Params* - список передаваемых контракту значений; по умолчанию, значения параметров контракта (секция data) берутся из HTML элементов (например, полей формы) с одноименными идентификаторами (id); если идентификаторы элементов, значения которых требуется передать в контракт, отличаются от названий параметров контракта, то используется присваивание парамтеров в формате ``contractField1=idname1, contractField2=idname2``; 
* *PageParams* - параметры для перехода на страницу в формате ``contractField1=idname1, contractField2=idname2`` (особенности передачи параметров см. в разделе выше "*Передача параметров странице через PageParams*").

**Alert** - используется для вывода сообщений.

* *Text* - текст сообщения,
* *ConfirmButton* - текст кнопки подтверждения,
* *CancelButton* - текст кнопки отмены,
* *Icon* - иконка.

**Style** - служит для указания css стилей.

* *Style* - css стили.

.. code:: js

      Button(Submit, default_page, mybtn_class).Alert(Alert message)
      Button(Contract: MyContract, Body:My Contract, Class: myclass, Params:"Name=myid,Id=i10,Value")

CmpTime(Time1, Time2) 
==============================
Функция сравнивает два значения времени в одинаковом формате (желательно стандартном - ``YYYY-MM-DD HH:MM:SS``, но можно и в произвольном при условии соблюдения последовательности от годов к секундам, например, ``YYYYMMDD``). Возвращает: 

* **-1** - Time1 < Time2, 
* **0** - Time1 = Time2, 
* **1** - Time1 > Time2.

.. code:: js

     If(CmpTime(#time1#, #time2#)<0){...}

Code(Text)
==========================
Создает элемент **code** для вывода указанного кода.

* *Text* - исходный код, который необходимо вывести.

.. code:: js

      Code( P(This is the first line.
          Span(This is the second line.))
      )
 
Data(Source,Columns,Data) [.Custom(Column,Body)]
==========================
Создает элемент **data** и заполняет его указанными данными. В *attr* возвращаются три массива - *columns* c именами колонок, *types*, где для обычной колонки указан *text*, а для Custom колонок указан тип *tags* и массив *data* с записями. Последовательность в именах колонок соответствует последовательности значений в записях в *data*.

* *Source* - имя источника данных, которое потом будет указываться в других командах (например, *Table*) как источник данных,
* *Columns* - список колонок; данные должны быть идти в таком же порядке, 
* *Data* - данные по одной записи на строку с разделением на колонки через запятую. Можно заключать значения в двойные кавычки. Если нужно вставить кавычки, то их нужно удвоить.

* **Custom** - позволяет определять вычисляемые столбцы для данных, например, можно указывать шаблон для кнопок и дополнительного оформления. Можно определять несколько таких вычисляемых столбцов. Как правило, такие поля определяются для вывода в *Table* и других командах, которые используют полученные данные.

  * *Column* - имя колонки (любое уникальное имя),
  * *Body* - укажите шаблон, в котором можно получать значения из других колонок в данной записи с помощью **#columnname#**.

.. code:: js

    Data(mysrc,"id,name"){
	"1",John Silver
	2,"Mark, Smith"
	3,"Unknown ""Person"""
     }

DateTime(DateTime, Format) 
==============================
Функция выводит значение даты и времени в заданном формате. 
 
*  *DateTime* - время в стандартном формате ``2006-01-02T15:04:05``.
*  *Format* -  шаблон формата : YY короткий год, YYYY полный год, MM - месяц, DD - день, HH - часы, MM - минуты, SS – секунды, например, ``YY/MM/DD HH:MM``. Если формат не указан, то будет использовано значение параметра  *timeformat* определенное в таблице *languages*, если его нет, то ``YYYY-MM-DD HH:MI:SS``.

.. code:: js

    DateTime(2017-11-07T17:51:08)
    DateTime(#mytime#,HH:MI DD.MM.YYYY)

DBFind(Name, Source) [.Columns(columns)] [.Where(conditions)] [.WhereId(id)] [.Order(name)] [.Limit(limit)] [.Offset(offset)] [.Ecosystem(id)] [.Custom(Column,Body)] [.Vars(Prefix)]
==========================
Создает элемент **dbfind** и возвращает данные из таблицы базы данных. В *attr* возвращаются три массива - *columns* c именами колонок, *types*, где для обычной колонки указан *text*, а для Custom колонок указан тип *tags* и массив *data* с записями. Последовательность в именах колонок соответствует последовательности значений в записях в *data*.

* *Name* - имя таблицы.
* *Source* - имя источника данных. Вы можете указать любое имя, которое потом будет указываться в других командах (например. *Table*) как источник данных.

* **Columns** - список возвращаемых колонок. Если не указано, то возвратятся все колонки, 
* **Where** - условие поиска. Например, ``.Where(name = '#myval#')``,
* **WhereId** - условие поиска по идентификатору. Достаточно указать значение идентификатора;  например, ``.WhereId(1)``,
* **Order** - поле, по которому нужно отсортировать. 
* **Limit** - количество возвращаемыхх записей. По умолчанию, 25. Максимально возможно количество - 250,
* **Offset** - смещение возвращаемых записей,
* **Ecosystem** - идентификатор экосистемы: по умолчанию, берутся данные из таблицы в текущей экосистеме,
* **Custom** - позволяет определять вычисляемые столбцы для данных. Например, можно указывать шаблон для кнопок и дополнительного оформления. Можно определять несколько таких вычисляемых столбцов. Как правило, такие поля определяются для вывода в *Table* и других командах, которые используют полученные данные.

  * *Column* - имя колонки; нужно определить любое уникальное имя,
  * *Body* - укажите шаблон; в нем можно получать значения из других колонок в данной записи с помощью **#columnname#**.

* **Vars** - Функция формирует множество переменных со значениями из записи таблицы базы данных, полученной по данному запросу. При указании этой функции, параметр *Limit* автоматически становится равным 1 и возвращается только одна запись.

* *Prefix* - префикс, используемый для образования имен переменных, в которые записываются значения полученной записи: переменные имеют вид *#prefix_id#, #prefix_name#*, где после знака подчеркивания указывается имя колонки таблицы.

.. code:: js

    DBFind(parameters,myparam)
    DBFind(parameters,myparam).Columns(name,value).Where(name='money')
    DBFind(parameters,myparam).Custom(myid){Strong(#id#)}.Custom(myname){
       Strong(Em(#name#))Div(myclass, #company#)
    }

Div(Class, Body) [.Style(Style)]
==========================
Создает HTML элемент **div**.

* *Class* - классы для данного *div*.
* *Body* - дочерние элементы.

**Style** - служит для указания css стилей.

* *Style* - css стили.

.. code:: js

      Div(class1 class2, This is a paragraph.)

EcosysParam(Name, Index, Source) 
==============================
Функция выводит значение параметра из таблицы parameters текущей экосистемы. Если есть языковый ресурс c полученным именем, то подставится его значение.
 
* *Name* - имя значения;
* *Index* - вы можете указать порядковый номер значения c 1, если параметр является список с элементами раззделенными запятыми. например, ``gender = male,female``, тогда ``EcosysParam(gender, 2)`` возвратит *female*.  
* *Source* - вы можете получить значения параметра разделенными запятыми в виде объекта *data*. В дальнейшем этот список можно указывать в качестве источника данных как для *Table*, так и для *Select*. Если вы указывайте этот параметр, то функция не будет возвращать значение, а возвратит список в виде объекта *data*.

.. code:: js

     Address(EcosysParam(founder_account))
     EcosysParam(gender, Source: mygender)
 
     EcosysParam(Name: gender_list, Source: src_gender)
     Select(Name: gender, Source: src_gender, NameColumn: name, ValueColumn: id)
     
Em(Body, Class)
==========================
Создает HTML элемент **em**.

* *Body* - дочерний текст или элементы.
* *Class* - классы для данного *em*.

.. code:: js

      This is an Em(important news).

ForList(Source, Body)
==========================
Выводит список элементов из источника данных *Source* в формате шаблона, заданного в *Body*. Создает элемент **forlist**.

* *Source* - источник данных из функций *DBFind* или *Data*.
* *Body* - шаблон, в котором выводится каждый эелемент.

.. code:: js

      ForList(mysrc){Span(#name#)}

Form(Class, Body) [.Style(Style)]
==========================
Создает HTML элемент **form**.

* *Class* - классы для данного *form*.
* *Body* - дочерние элементы.

**Style** - служит для указания css стилей.

* *Style* - css стили.

.. code:: js

      Form(class1 class2, Input(myid))
      
GetVar(Name)
==========================
Функция возвращает значение указанной переменной, если она существует, и возвращает пустую строку, если переменная с данным именем не определена. Элемент с именем **getvar** создается только при запросе дерева для редактирования. Отличие ``GetVar(varname)`` от использования *#varname#* состоит в том, что если *varname* не существует, то *GetVar* возвратит пустую строку, а *#varname#* так и останется.

* *Name* - имя переменной.

.. code:: js

     If(GetVar(name)){#name#}.Else{Name is unknown}
      
If(Condition){ Body } [.ElseIf(Condition){ Body }] [.Else{ Body }]
==========================
Условный оператор. Возвращаются дочерние элементы первого *If* или *ElseIf* у которого выполнено условие *Condition*. В противном случае, возвращаются дочерние элементы *Else*, если он присутствует.

* *Condition* - Условие. Считается не выполненным если равно *пустой строке*, *0* или *false*. В остальных случаях, условие считается истинным.
* *Body* - дочерние элементы.

.. code:: js

      If(#value#){
         Span(Value)
      }.ElseIf(#value2#){Span(Value 2)
      }.ElseIf(#value3#){Span(Value 3)}.Else{
         Span(Nothing)
      }

Image(Src,Alt,Class) [.Style(Style)]
==============================
Создает HTML элемент **image**.
 
* *Src* - источник изображения, файл или ``data:...``;
* *Alt* - альтернативный текст для изображения; 
* *Сlass* - список классов.

.. code:: js

    Image(\images\myphoto.jpg)

ImageInput(Name, Width, Ratio, Format) 
==============================
Создает элемент **imageinput** для загрузки картинок. По желанию в третьем параметре можно указать либо высоту картинки, либо отношение сторон в виде *1/2*, *2/1*, *3/4* и т.п. По умолчанию берется ширина в 100 пикселей и отношение сторон *1/1*.

* *Name* - имя элемента;
* *Width* - ширина вырезаемого изображения;
* *Ratio* - отношение сторон (ширины к высоте) или высота картинки.
* *Format* - формат загружаемой картинки.

.. code:: js

   ImageInput(avatar, 100, 2/1)

Include(Name)
==========================
Команда вставляет шаблон с именем *Name* из таблицы *blocks*. При вставке происходит разбор шаблона и происходит вставка разобранных элементов.

* *Name* - Имя вставляемого шаблона из таблицы *blocks*.

.. code:: js

      Div(myclass, Include(mywidget))

Input(Name,Class,Placeholder,Type,Value) [.Validate(validation parameters)] [.Style(Style)]
==========================
Создает HTML элемент **input**.

* *Name* - имя элемента,
* *Class* - классы для данного *input*,
* *Placeholder* - *placeholder* для данного *input*,
* *Type* - типа для данного *input*,
* *Value* - значение элемента.

**Validate** - параметры валидации.

**Style** - служит для указания css стилей.

* *Style* - css стили.

.. code:: js

      Input(Name: name, Type: text, Placeholder: Enter your name)
      Input(Name: num, Type: text).Validate(minLength: 6, maxLength: 20)

InputErr(Name,validation errors)]
==========================
Создает элемент **inputerr** c текстами для ошибок валидации.

* *Name* - имя соответствующего элемента **Input**.

.. code:: js

      InputErr(Name: name, 
          minLength: Value is too short, 
          maxLength: The length of the value must be less than 20 characters)

Label(Body, Class, For) [.Style(Style)]
==========================
Создает HTML элемент **label**.

* *Body* - дочерний текст или элементы,
* *Class* - классы для данного *label*,
* *For* - значение *for* для данного *label*.

**Style** - служит для указания css стилей.

* *Style* - css стили.

.. code:: js

      Label(The first item).
      
LangRes(Name, Lang)
==========================
Возвращает указанный языковой ресурс. В случае запроса дерева для редактирования возвращается элемент **langres**. Кроме этой команды можно использовать записи вида **$langres$**, которые будут заменяться на значения указанного языкового ресурса.

* *Name* - имя языкового ресурса,
* *Lang* - по умолчанию, возвращается язык который определен в запросе в *Accept-Language*; при желании вы можете указать свой двухсивольный идентификатор языка.

.. code:: js

      LangRes(name)
      LangRes(myres, fr)

LinkPage(Body, Page, Class, PageParams) [.Style(Style)]
==========================
Создает элемент **linkpage** для ссылки на страницу. 

* *Body* - дочерний текст или элементы,
* *Page* - название страницы для перехода,
* *Class* - классы для данной кнопки,
* *PageParams* - параметры для перехода на страницу.

**Style** - служит для указания css стилей.

* *Style* - css стили.

.. code:: js

      LinkPage(My Page, default_page, mybtn_class)

MenuGroup(Title, Body, Icon) 
==============================
Функция формирует в меню вложенное подменю и возвращает элемент **menugroup**. В параметре *name* также будет возвращено значение *Title* до подстановки языковых ресурсов.

* *Title* - имя пункта меню,
* *Body* - дочерние элементы подменю,
* *Icon* - иконка.

.. code:: js

      MenuGroup(My Menu){
          MenuItem(Interface, sys-interface)
          MenuItem(Dahsboard, dashboard_default)
      }

MenuItem(Title, Page, Params, Icon, Vde) 
==============================
Служит для создания пункта меню и возвращает элемент **menuitem**. 

* *Title* - имя пункта меню,
* *Page* - имя страницы перехода,
* *Params* - параметры, передаваемые странице в формате *var:value* через запятую,
* *Icon* - иконка,
* *Vde* - параметр, определяющий переход на виртуальную экосистему; если ``Vde: true``, то ссылка ведёт в VDE, если ``Vde: false``, то в блокчейн, если параметр не указан, то решается в зависимости от того, где было загружено меню.

.. code:: js

       MenuItem(Interface, interface)

Now(Format, Interval) 
==============================
Функция возвращает текущее время в указанном формате, по умолчанию выводится  в UNIX-формате (число секунд с 1970 года). Если в качестве формата указано *datetime*, то дата и время выводится в виде ``YYYY-MM-DD HH:MI:SS``. Во втором параметре можно указать интервал, например, *+5 days*.

* *Format* - формат вывода с комбинацией ``YYYY, MM, DD, HH, MI, SS`` или *datetime*;
* *Interval* - дополнтельный сдвиг времени назад или вперед;

.. code:: js

       Now()
       Now(DD.MM.YYYY HH:MM)
       Now(datetime,-3 hours)

Or(parameters)
==========================
Функция возвращает результат выполнения логической операции **ИЛИ** со всеми перечисленными в скобках через запятую параметрами. Значение параметра принимается как **false**, если он равен пустой строке (""), 0 или *false*. Во всех остальных случаях значение параметра считается **true**. Соответственно функция возвращает 1 в случае истины и в противном случае 0. Элемент с именем **or** создается только при запросе дерева для редактирования. 

.. code:: js

      If(Or(#myval1#,#myval2#), Span(OK))

P(Body, Class) [.Style(Style)]
==========================
Создает HTML элемент **p**.

* *Body* - дочерний текст или элементы,
* *Class* - классы для данного *p*.

**Style** - служит для указания css стилей.

* *Style* - css стили.

.. code:: js

      P(This is the first line.
        This is the second line.)


RadioGroup(Name, Source, NameColumn, ValueColumn, Value, Class) [.Validate(validation parameters)] [.Style(Style)]
==========================
Создает элемент **radiogroup**.

* *Name* - имя элемента,
* *Source* - имя источника данных из функций *DBFind* или *Data*,
* *NameColumn* - имя колонки, из которой получаются имена элементов,
* *ValueColumn* - имя колонки, из которой получаются значения элементов; в этом параметре нельзя указывать имена колонок созданных через Custom,
* *Value* - Значение по умолчанию,
* *Class* - Классы для элемента.

**Validate** - параметры валидации.

**Style** - служит для указания css стилей.

* *Style* - css стили.

.. code:: js

      DBFind(mytable, mysrc)
      RadioGroup(mysrc, name)

Select(Name, Source, NameColumn, ValueColumn, Value, Class) [.Validate(validation parameters)] [.Style(Style)]
==========================
Создает HTML элемент **select**.

* *Name* - имя элемента,
* *Source* - имя источника данных. Например, из команды *DBFind* или *Data*,
* *NameColumn* - имя колонки, из которой будeт браться текст для элементов,
* *ValueColumn* - имя колонки, из которой будут браться значения для элементов. В этом параметре нельзя указывать имена колонок созданных через Custom,
* *Value* - Значение по умолчанию,
* *Class* - Классы для элемента.

**Validate** - параметры валидации.

**Style** - служит для указания css стилей.

* *Style* - css стили.

.. code:: js

      DBFind(mytable, mysrc)
      Select(mysrc, name)

SetTitle(Title)
==========================
Устанавливает заголовок страницы. Создается элемент с именем **settitle**.

* *Title* - заголовок страницы.

.. code:: js

     SetTitle(My page)

SetVar(Name, Value)
==========================
Присваивает переменной с именем *Name* значение *Value*. Элемент с именем **setvar** создается только при запросе дерева для редактирования.

* *Name* - имя переменной,
* *Value* - значение переменной, может содержать ссылку на другие переменные.

.. code:: js

     SetVar(name, John Smith).(out, I am #name#)
     Span(#out#)

Span(Body, Class) [.Style(Style)]
==========================
Создает HTML элемент **span**.

* *Body* - дочерний текст или элементы,
* *Class* - классы для данного *span*.

**Style** - служит для указания css стилей.

* *Style* - css стили.

.. code:: js

      This is Span(the first item, myclass1).

Strong(Body, Class)
==========================
Создает HTML элемент **strong**.

* *Body* - дочерний текст или элементы,
* *Class* - классы для данного *strong*.

.. code:: js

      This is Strong(the first item, myclass1).

SysParam(Name) 
==============================
Функция выводит значение системного параметра из таблицы system_parameters.
 
* *Name* - имя значения.

.. code:: js

     Address(SysParam(founder_account))

Table(Source, Columns) [.Style(Style)]
==========================
Создает HTML элемент **table**.

* *Source* - имя источника данных. Например, из команды *DBFind*,
* *Columns* - Заголовки и соответствующие имена колонок в виде ``Title1=column1,Title2=column2``.

**Style** - служит для указания css стилей.

* *Style* - css стили.

.. code:: js

      DBFind(mytable, mysrc)
      Table(mysrc,"ID=id,Name=name")
