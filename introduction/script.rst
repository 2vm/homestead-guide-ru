################################################################################
Смарт-контракты
################################################################################
.. contents::
  :local:
  :depth: 2

Смарт-контракт (далее просто “контракт”) - это базовый элемент приложений, с помощью которого реализуется выполнение единичного действия (обычно записи в таблицу базы данных), инициированного в интерфейсе пользователем или другим контрактом. Все операции с данными в приложениях оформляется в виде системы контрактов, взаимодействующих через таблицы базы данных или путем вызова друг с друга в теле контракта.

Контракты Apla пишутся на оригинальном (разработанном командой Apla) тьюринг-полном скриптовом языке Simvolio с компиляцией в байт-код. Язык содержит необходимый набор функций, операторов и конструкций  для реализации алгоритмов обработки данных и операций со значениями.

Контракты могут редактироваться  (если при его создании эта возможность не была запрещена указанием ``false`` в правах доступа к редактированию контракта). Операции с данными блокчейна выполняет актуальная (последняя по времени) версия контракта. Вся история изменений контрактов сохраняется в блокчейне и доступна в программном клиенте.

********************************************************************************
Структура контракта
********************************************************************************
Контракт определяется ключевым словом contract, после которого указывается имя контракта. Тело контракта заключается в фигурные скобки. Контракт состоит из трех секций: 

1. **data** - используется для описания входящих данных (имена переменных и их типы),
2. **conditions** - реализует проверку входных данных на корректность,
3. **action** - содержит описание действия контракта. 

Структура контракта:

.. code:: js

  contract MyContract {
      data {
          FromId address
          ToId   address
          Amount money
      }
      func conditions {
          ...
      }
      func action {
      }
  }


Cекция data
==============================

Входные данные контракта, а так же параметры формы для приема этих данных описываются в секции ``data``. 
Данные перечисляются построчно: сначала указывается имя переменной (передаются только переменные, а не массивы), затем тип и опционально через пробел в двойных кавычках параметры для построения формы интерфейса:

* *hidden* - скрытый элемент формы,
* *optional* - элемент формы без обязательного заполнения,
* *date* - поле выбора даты и времени,
* *polymap* - карта с выбором координат и областей,
* *map* - карта с возможностью отметить место,
* *image* - загрузка изображений,
* *text* - ввод текста или HTML-кода в поле textarea,
* *crypt:Field* - создание и шифрование приватного ключа для адресата указанного в поле ``Field``, если указано только ``crypt``, то приватный ключ создастся для того пользователя, который подписывает контракт,
* *address* - поле для ввода адреса кошелька,
* *signature:contractname* - строка для вызова контракта contractname, который требует подписи (подробно рассматривается в специально разделе описания).

.. code:: js

  contract my {
    data {
        Name string 
        RequestId address
        Photo bytes "image optional"
        Amount money
        Private bytes "crypt:RequestId"
    }
    ...
  }
  
Секция conditions
==============================
в секции реализуется проверка входных данных с выводом сообщений об ошибках с помощью команд: ``error``, ``warning``, ``info``. Все эти команды генерируют ошибку, останавливающую работу контракта, но выводят в интерфейсе различные сообщения: *критическая ошибка*, *предупреждение*, и *информативная ошибка*. Например, 

.. code:: js

  if fuel == 0 {
        error "fuel cannot be zero!"
  }
  if money < limit {
        warning Sprintf("You don't have enough money: %v < %v", money, limit)
  }
  if idexist > 0 {
        info "You have been already registered"
  }

Секция action
==============================  
Секция action содержит основной программный код контракта выполняющий получение дополнительных данных и запись результата в таблицы базы данных. Например,

.. code:: js

	action {
		DBUpdate("keys", $key_id,"-amount", $amount)
		DBUpdate("keys", $recipient,"+amount,pub", $amount, $Pub)
	}


Переменные в контракте
==============================
Входные данные контракта, описанные в секции data,  передаются в другие секции через переменные с именами данных и с символом  ``$`` перед ними. Возможно определить и дополнительные переменные со знаком ``$``, которые будут глобальными в рамках выполнения контракта, включая вложенные контракты. 

В контракте доступны и предопределенные переменные, содержащие данные о транзакции, из которой был вызван данный контракт.

* *$time* - время транзакции int,
* *$ecosystem_id* - идентификатор экосистемы int,
* *$block* - номер блока, в который запечатана транзакция int,
* *$key_id* - адрес кошелька подписавшего транзакцию, если контракт вне экосистемы с ``ecosystem_id == 0``,
* *$wallet_block* - адрес ноды, сформировавшей блок, в который входит транзакция,
* *$block_time* - время формирования блока, который содержит транзакцию с текущим контрактом.

Предопределенные переменные доступны не только в контрактах, но и в полях Permissions, в которых указываются условия доступа к элементам приложений (таблицам, контрактам, страницам и пр.) для составления логических выражений. При этом переменные имеющие отношения к формированию блока (``$time``, ``$block`` и др.) имеют нулевое значение.

Предопределенная переменной ``$result`` используется при необходимости возвратить значение из вложенного контракта.

.. code:: js

  contract my {
    data {
        Name string 
        Amount money
    }
    func conditions {
        if $Amount <= 0 {
           error "Amount cannot be 0"
        }
        $ownerId = 1232
    }
    func action {
        DBUpdate("mytable", $ownerId, "name,amount", $Name, $Amount - 10 )
        DBUpdate("mytable2", $citizen, "amount", 10 )
    }
  }
  
********************************************************************************
Вложенные контракты
********************************************************************************
В секциях *conditions* и *action* контракта может быть вызван другой контракт с передачей ему данных из текущего контракта.  Вызов вложенного контракта возможен как непосредственно, с указанием параметров в скобках после его имени (``NameContract(Params)``), так и с помощью функции *CallContract*, для которой имя контракта передается через строковую переменную.

********************************************************************************
Контракты с подписью
********************************************************************************
Поскольку язык написания контрактов позволяет выполнять вложенные контракты, то существует возможность выполнения такого вложенного контракта без ведома пользователя запустившего внешний контракт, что может привести к подписи пользователем несанкционированных им транзакций, скажем перевода денег со своего счета.

К примеру, пусть имеется контракт перевода токенов *TokenTransfer*:

.. code:: js

    contract TokenTransfer {
        data {
          Recipient int
          Amount    money
        }
        ...
    }

Если в некотором контракте, запущенном пользователем, будет вписана строка  ``TokenTransfer("Recipient,Amount", 12345, 100)``, то будет осуществлен перевод 100 монет на аккаунт 12345. При этом пользователь, подписывающий внешний контракт, останется не в курсе осуществленной транзакции. Исключить такую ситуацию возможно, если контракт TokenTransfer будет требовать получения дополнительной подписи пользователя при вызове его из других контрактов. Для этого необходимо:

1. Добавить в секцию ``data`` контракта *TokenTransfer* поле с именем **Signature** с параметрами ``optional`` и ``hidden``, которые позволяют не требовать дополнительной подписи при прямом вызове контракта, поскольку в поле **Signature** уже будет подпись.

.. code:: js

    contract TokenTransfer {
        data {
          Recipient int
          Amount    money
          Signature string "optional hidden"
        }
        ...
    }


2. Добавить в таблицу *Signatures* (на странице **Signatures** программного клиента Apla) запись содержащую: 

* имя контракта *TokenTransfer*, 
* имена полей, значения которых будут показываться пользователю, и их текстовое описание, 
* текст, который будет выводиться при подтверждении. 
  
В текущем примере достаточно указать два поля **Receipient** и **Amount**:

* **Title**: Are you agree to send token this recipient?
* **Parameter**: *Receipient* Text: Wallet ID
* **Parameter**: *Amount* Text: Amount (qEGS)

Теперь если вставить вызов контракта ``TokenTransfer("Recipient, Amount", 12345, 100)``, то будет получена системная ошибка ``"Signature is not defined"``. Если же контракт будет вызван следующим образом ``TokenTransfer("Recipient, Amount, Signature", 12345, 100, "xxx...xxxxx")``, то возникнет ошибка при проверке подписи. При вызове контракта проверяется подпись следующих данных: *время оригинальной транзакции, id пользователя, значение полей указанных в таблице signatures*, и подделать эту подпись невозможно.

Для того, чтобы пользователь при вызове контракта *TokenTransfer* увидел подтверждение на перевод денег, во внешний контракт необходимо добавить поле с произвольным названием и типом ``string`` и дополнительным параметром ``signature:contractname``. При вызове вложенного контракта *TokenTransfer* необходимо просто передать этот параметр. Также следует иметь в виду, что параметры для вызова защищенного контракта должны также быть описаны в секции ``data`` внешнего контракта (они могут быть скрытыми, но они все равно будут отображаться при подтверждении). Например,

.. code:: js

    contract MyTest {
      data {
          Recipient int "hidden"
          Amount  money
          Signature string "signature:TokenTransfer"
      }
      func action {
          TokenTransfer("Recipient,Amount,Signature",$Recipient,$Amount,$Signature)
      }
    }

При отправке контракта *MyTest*, у пользователя будет запрошено дополнительное подтверждение для перевода суммы на указанный аккаунт. Если во вложенном контракте будут указаны другие значения, например ``TokenTransfer("Recipient,Amount,Signature",$Recipient, $Amount+10, 
$Signature)``, то будет получена ошибку, что подпись неверна.

********************************************************************************
Редактор контрактов
********************************************************************************
Контракты создаются и редактируются в специальном редакторе программного клиента Molis. При создании нового контракта в него уже вписана типовая структура с тремя секциями ``data, conditions, action``.  Редактор контрактов обеспечивает:

- написание кода контрактов (с подсветкой ключевых слов языка Simvolio),
- форматирование кода контракта,
- привязку контракта к виртуальному аккаунту, с которого будет происходить оплата его работы,
- задание прав на редактирование контракта,
- просмотр истории изменения контрактов с возможностью восстановления прежних версий.


********************************************************************************
Язык написания контрактов Simvolio
********************************************************************************
Контракты Apla пишутся на оригинальном (разработанном командой Apla) тьюринг-полном скриптовом языке Simvolio с компиляцией в байт-код. Язык содержит необходимый набор функций, операторов и конструкций  для реализации алгоритмов обработки данных и операций со значениями базы данных. Язык Simvolio обеспечивает:

- объявление переменных с различными типами значений, а также простых и ассоциативных массивов: ``var, array, map``,
- использование условной конструкции ``if`` и конструкции цикла ``while``,
- получение значений из базы данных и запись значений в базу данных ``DBFind, DBInsert, DBUpdate``,
- работу с контрактами,
- преобразование значений переменных,
- операции со строковыми значениями.


Встроенные функции языка написания контрактов
==============================
Функции языка написания контрактов выполняют операции с данными полученными в секции ``data`` контракта: чтение значений из базы данных и запись значений в базу данных, преобразование типов значений и установление связи между контрактами. 

Функции не возвращают ошибок, так как все проверки на ошибки происходят автоматически.
При генерации ошибки в любой из функции, контракт прекращает свою работу и выводит описание ошибки в специальном окне.
