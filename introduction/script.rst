################################################################################
Язык написания контрактов
################################################################################

Целью создания специального языка для написания контрактов было желание сделать простой скриптовый язык с быстрой компиляцией в байт-код. При этом все контракты должны быть в едином пространстве и "на лету" добавлялись бы новые контракты. Язык должен поддерживать базовые типы, переменные, функции, стандартный набор операторов и специальную обработку ошибок при которой контракт прекращает работу при возникновении ошибки в любой вызванной функции. 

Так как контракты являются общими для всех, то все они компилируются в байт-код, и он хранится в памяти в одном месте. При вызове контракта, происходит создание изолированного стэка с входящими данными, с которым и работает виртуальная машина выполняя байт-код. Таким образом, на одном и том же байт-коде может одновременно выполнятся множество процессов, которые не будут влиять друг на друга, так как каждый процесс имеет свой собственный стэк и набор переменные.

********************************************************************************
Типы и переменные
********************************************************************************

Язык является типизированным языком. Переменные перед использованием должны быть описаны с указанием типа. Где возможно, там применяется автоматическое преобразование типов. Имеются следующие базовые типы.

* **bool** - булевый тип, может принимать значения *true* или *false*.
* **bytes** - последовательность байтов.
* **int** - 64-разрядный integer.
* **address** - 64-разрядный беззнаковый integer.
* **array** - массив произвольных типов.
* **map** - ассоциативный массив произвольных типов со строковыми ключами.
* **money** - денежный тип big integer. Деньги изначально не имеют десятичных точек, они могут вставляться при выводе в соответствии с настройками валюты.
* **float** - 64-разрядное число с плавающей точкой.
* **string** - строка. Строки можно указывать в двойных или обратных кавычках - "This is a line" или `This is a line`

Все идентификаторы регистрозависимы, то есть MyFunc и myFunc - это разные имена. Переменные определяются с помощью ключевого слова **var**, далее идут имя или имена переменных и тип. Переменные могут определеться внутри любых фигурных скобок. При описании переменных им автоматически присваивается значение по умолчанию. Для *bool* это false, для всех *числовых* типов - это нулевые значения, для *строк* - пустая строка. Примеры определения переменных. 

.. code:: js

  func myfunc( val int) int {
      var mystr1 mystr2 string, mypar int
      var checked bool
      ...
      if checked {
           var temp int
           ...
      }
  }


********************************************************************************
Конструкции языка
********************************************************************************

Существуют две базовые конструкции, которые можно использовать на верхнем уровне в исходном коде - функции и контракты.

**Функции** описывается  спомощью ключевого слова **func**, после которого идет имя функции, параметры с указанием типа в круглых скобках и тип возвращаемого значения. Тело функции начинается с фигурных скобок. Если функция не имеет параметров, то круглые скобки можно опускать. Для возвращения значения из функции используется ключевое слово **return**.

.. code:: js

  func myfunc(left int, right int) int {
      return left*right + left - right
  }
  func test int {
      return myfunc(10, 30) + myfunc(20, 50)
  }
  func ooops {
      error "Ooops..."
  }

**Контракт** - это более сложная структура, которая определяется ключевым словом **contract** и именем. Контракт может включать в себя структуру с входящими данными, которая описывается с помощью ключевого слова **data** и внутренними функциями. Вы можете определять внутри контракта функции с любыми имена, но в текущий момент при выполнении контракта вызываются следующие функции: **init, conditions, action**. Функция *init* на практике не используется, в функции *conditions* нужно проверить входящие данные на корректность и, если необходимо, проверить дополнительные условия. В функции *action* необходимо описать сами действия, которые выполняет контракт.

В большинстве случаев контракту нужны входящие данные. Они описываются с помощью ключевого слова **data** и далее указываются имена и типы. Подробнее это будет разобрано ниже.

.. code:: js

  contract MyContract {
      data {
          FromId address
          ToId   address
          Amount money
      }
      func conditions {
          ...
      }
      func action {
      }
  }

Внутри функций можно использовать условную конструкцию **if** и конструкцию цикла **while**. Эти конструкции можно вкладывать друг в друга. После ключевого слова должно идти условное выражение. Если в качестве условного выражения указано выражение возвращающее число, то в этом случае выражение считается ложь, если число равно 0. Например, *val == 0* эквивалентно *!val*, а *val != 0* тоже самое, что просто *val*.  Конструкция **if** может иметь блок **else**, который будет выполняться если условие для **if** ложно. В условном выражении можно использовать операции сравнения: *<, >, >=, <=, ==, !=*, а также || (ИЛИ) и && (И).

.. code:: js

    if val > 10 || id != $citizen {
      ...
    } else {
      ...
    }

Конструкция **while** предназначена для реализации циклов. Блок **while** выполняется до тех пор, пока его условие **истино**. Для прекращения цикла внутри блока можно использовать оператор **break**. Если вы хотите не доходить до конца, а заново начать блок цикла, то используйте оператор **continue**.

.. code:: js

  while true {
      if i > 100 {
         break
      }
      ...
      if i == 50 {
         continue
      }
      ...
  }

********************************************************************************
Описание раздела data
********************************************************************************


********************************************************************************
Обработка ошибок
********************************************************************************

Когда выполняется контракт, ошибка в любой из функции должна приводить к прекращению работы контракта и возврату данной ошибки. Если требовать постоянной проверки кодов возврата, то это приведет к излишним проверкам, а игнорирование таких проверок при сбое будет приводит к неверной работе. Поэтому все ошибки обрабатываются автоматически, достаточно вызвать команду генерации ошибки и текущий контракт закончит работу и вернет данную ошибку.  

Существует три команды для прекращения работы контракта: **error, warning, info**. По сути они все генерируют ошибку, но ошибка будет возвращаться с тремя различными типами: критическая ошибка, предупреждение, и информативная ошибка. Соответственно, в браузере можно выводить каждую из ошибок в разном оформлении и с разной дополнительной информацией. Например,

.. code:: js

  if fuel == 0 {
        error "fuel cannot be zero!"
  }
  if money < limit {
        warning Sprintf("You don't have enough money: %v < %v", money, limit)
  }
  if idexist > 0 {
        info "You have been already registered"
  }

