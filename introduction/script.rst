################################################################################
Язык написания контрактов
################################################################################

Целью создания специального языка для написания контрактов было желание сделать простой скриптовый язык с быстрой компиляцией в байт-код. При этом все контракты должны быть в едином пространстве и "на лету" добавлялись бы новые контракты. Язык должен поддерживать базовые типы, переменные, функции, стандартный набор операторов и специальную обработку ошибок при которой контракт прекращает работу при возникновении ошибки в любой вызванной функции. 

Так как контракты являются общими для всех, то все они компилируются в байт-код, и он хранится в памяти в одном месте. При вызове контракта, происходит создание изолированного стэка с входящими данными, с которым и работает виртуальная машина выполняя байт-код. Таким образом, на одном и том же байт-коде может одновременно выполнятся множество процессов, которые не будут влиять друг на друга, так как каждый процесс имеет свой собственный стэк и набор переменные.

********************************************************************************
Типы и переменные
********************************************************************************

Язык является типизированным языком. Переменные перед использованием должны быть описаны с указанием типа. Где возможно, там применяется автоматическое преобразование типов. Имеются следующие базовые типы.

* **bool** - булевый тип, может принимать значения *true* или *false*.
* **bytes** - последовательность байтов.
* **int** - 64-разрядный integer.
* **address** - 64-разрядный беззнаковый integer.
* **array** - массив произвольных типов.
* **map** - ассоциативный массив произвольных типов со строковыми ключами.
* **money** - денежный тип big integer. Деньги изначально не имеют десятичных точек, они могут вставляться при выводе в соответствии с настройками валюты.
* **float** - 64-разрядное число с плавающей точкой.
* **string** - строка. Строки можно указывать в двойных или обратных кавычках - "This is a line" или `This is a line`

Все идентификаторы регистрозависимы, то есть MyFunc и myFunc - это разные имена. Переменные определяются с помощью ключевого слова **var**, далее идут имя или имена переменных и тип. Переменные могут определеться внутри любых фигурных скобок. При описании переменных им автоматически присваивается значение по умолчанию. Для *bool* это false, для всех *числовых* типов - это нулевые значения, для *строк* - пустая строка. Примеры определения переменных. 

.. code:: js

  func myfunc( val int) int {
      var mystr1 mystr2 string, mypar int
      var checked bool
      ...
      if checked {
           var temp int
           ...
      }
  }


********************************************************************************
Конструкции языка
********************************************************************************

Существуют две базовые конструкции, которые можно использовать на верхнем уровне в исходном коде - функции и контракты.

**Функции** описывается  спомощью ключевого слова **func**, после которого идет имя функции, параметры с указанием типа в круглых скобках и тип возвращаемого значения. Тело функции начинается с фигурных скобок. Если функция не имеет параметров, то круглые скобки можно опускать. Для возвращения значения из функции используется ключевое слово **return**.

.. code:: js

  func myfunc(left int, right int) int {
      return left*right + left - right
  }
  func test int {
      return myfunc(10, 30) + myfunc(20, 50)
  }
  func ooops {
      error "Ooops..."
  }

**Контракт** - это более сложная структура, которая определяется ключевым словом **contract** и именем. Контракт может включать в себя структуру с входящими данными, которая описывается с помощью ключевого слова **data** и внутренними функциями. Вы можете определять внутри контракта функции с любыми имена, но в текущий момент при выполнении контракта вызываются следующие функции: **init, conditions, action**. Функция *init* на практике не используется, в функции *conditions* нужно проверить входящие данные на корректность и, если необходимо, проверить дополнительные условия. В функции *action* необходимо описать сами действия, которые выполняет контракт.

В большинстве случаев контракту нужны входящие данные. Они описываются с помощью ключевого слова **data** и далее указываются имена и типы. Подробнее это будет разобрано ниже.

.. code:: js

  contract MyContract {
      data {
          FromId address
          ToId   address
          Amount money
      }
      func conditions {
          ...
      }
      func action {
      }
  }

Внутри функций можно использовать условную конструкцию **if** и конструкцию цикла **while**. Эти конструкции можно вкладывать друг в друга. После ключевого слова должно идти условное выражение. Если в качестве условного выражения указано выражение возвращающее число, то в этом случае выражение считается ложь, если число равно 0. Например, *val == 0* эквивалентно *!val*, а *val != 0* тоже самое, что просто *val*.  Конструкция **if** может иметь блок **else**, который будет выполняться если условие для **if** ложно. В условном выражении можно использовать операции сравнения: *<, >, >=, <=, ==, !=*, а также || (ИЛИ) и && (И).

.. code:: js

    if val > 10 || id != $citizen {
      ...
    } else {
      ...
    }

Конструкция **while** предназначена для реализации циклов. Блок **while** выполняется до тех пор, пока его условие **истино**. Для прекращения цикла внутри блока можно использовать оператор **break**. Если вы хотите не доходить до конца, а заново начать блок цикла, то используйте оператор **continue**.

.. code:: js

  while true {
      if i > 100 {
         break
      }
      ...
      if i == 50 {
         continue
      }
      ...
  }

********************************************************************************
Массивы
********************************************************************************

Как было написано выше, в языке имеется два типа массивов: **array** - простой массив с индексом начиная с 0 и **map** - ассоциативный массив со строковыми ключами. Присваивание и получение элементов осуществляется указанием индекса в квадратных скобках. 

.. code:: js

    var myarr array
    var mymap map
    var s string
    
    myarr[0] = 100
    myarr[1] = "This is a line"
    mymap["value"] = 777
    mymap["param"] = "Parameter"

    s = Sprintf("%v, %v, %v", myarr[0] + mymap["value"], myarr[1], mymap["param"])
    // s = 877, This is a line, Parameter


********************************************************************************
Описание раздела data
********************************************************************************

Входящие параметры контракта описываются с помощью конструкции **data**. В начале указывается имя переменной, затем тип и опционально можно указать дополнительные параметры *name type ["parameters"]**. В качестве типа можно указывать любой тип, кроме массивов. Дополнительные параметры указываются через пробел в двойных кавычках в основном как будут отображаться контролы в шаблоне **TxForm**. Можно использовать следующие параметры.

* *hidden* - скрытый элемент.
* *optional* - элемент на форме не будет требовать заполнения.
* *date* - выбор даты и времени.
* *polymap* - карта с возможностью указания области.
* *map* - карта с возможностью отметить место.
* *image* - выбор картинки.
* *text* - ввод данных в HTML тэге textarea.
* *address* - специальный элемент с подсказкой адресов.
* *digit:X* - если переменная имеет тип money, то X обозначает количество цифр после десятичной точки при вводе денежной величины. 

.. code:: js

  contract my {
    data {
        Name string 
        RequestId address
        Photo bytes "image optional"
        Amount money
    }
    ...
  }

Для того, чтобы получить значение параметра внутри функции контракта, перед именем параметра необходимо указать символ **$**. Также, можно определять свои перемменные, которые будут глобальными переменными в рамках выполнения контракта. Кроме этого, существуют предопределенные переменные, которые содержат информацию о транзакции, из которой был вызван данный контракт.

* *$time* - время транзакции int.
* *$state* - идентификатор государства int.
* *$block* - номер блока, в который запечатана транзакция int.
* *$citizen* - адрес гражданина, подписавшего транзакцию int.
* *$wallet* - адрес кошелька подписавшего транзакцию, если контракт вне государства с state == 0.
* *$wallet_block* - адрес ноды, сформировавшей блок, в который входит транзакция.
* *$block_time* - время блока, который содержит транзакцию с текущим контрактом int.

.. code:: js

  contract my {
    data {
        Name string 
        Amount money
    }
    func conditions {
        if $Amount <= 0 {
           error "Amount cannot be 0"
        }
        $ownerId = 1232
    }
    func action {
        DBUpdate(Table("mytable"), $ownerId, "name,amount", $Name, $Amount - 10 )
        DBUpdate(Table("mytable2"), $citizen, "amount", 10 )
    }
  }
  
  


********************************************************************************
Обработка ошибок
********************************************************************************

Когда выполняется контракт, ошибка в любой из функции должна приводить к прекращению работы контракта и возврату данной ошибки. Если требовать постоянной проверки кодов возврата, то это приведет к излишним проверкам, а игнорирование таких проверок при сбое будет приводит к неверной работе. Поэтому все ошибки обрабатываются автоматически, достаточно вызвать команду генерации ошибки и текущий контракт закончит работу и вернет данную ошибку.  

Существует три команды для прекращения работы контракта: **error, warning, info**. По сути они все генерируют ошибку, но ошибка будет возвращаться с тремя различными типами: критическая ошибка, предупреждение, и информативная ошибка. Соответственно, в браузере можно выводить каждую из ошибок в разном оформлении и с разной дополнительной информацией. Например,

.. code:: js

  if fuel == 0 {
        error "fuel cannot be zero!"
  }
  if money < limit {
        warning Sprintf("You don't have enough money: %v < %v", money, limit)
  }
  if idexist > 0 {
        info "You have been already registered"
  }

