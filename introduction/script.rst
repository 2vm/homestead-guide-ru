################################################################################
Смарт контракты
################################################################################
.. contents::
  :local:
  :depth: 2

Смарт-контракт (далее просто “контракт”) - это базовый элемент приложений, с помощью которого реализуется выполнение единичного действия (обычно записи в таблицу базы данных), инициированного в интерфейсе пользователем или другим контрактом. Все операции с данными в приложениях оформляется в виде системы контрактов, взаимодействующих через таблицы базы данных или путем вызова друг с друга в теле контракта.

Контракты Apla пишутся на оригинальном (разработанном командой Apla) тьюринг-полном скриптовом языке Simvolio с компиляцией в байт-код. Язык содержит необходимый набор функций, операторов и конструкций  для реализации алгоритмов обработки данных и операций со значениями.

Контракты могут редактироваться  (если при его создании эта возможность не была запрещена указанием *false* в правах доступа к редактированию контракта). Операции с данными блокчейна выполняет актуальная (последняя по времени) версия контракта. Вся история изменений контрактов сохраняется в блокчейне и доступна в программном клиенте.

********************************************************************************
Структура контракта
********************************************************************************
Контракт определяется ключевым словом contract, после которого указывается имя контракта. Тело контракта заключается в фигурные скобки. Контракт состоит из трех секций: 

1. **data** - используется для описания входящих данных (имена переменных и их типы);
2. **conditions** - реализует проверку входных данных на корректность;
3. **action** - содержит описание действия контракта. 

Структура контракта:

.. code:: js

  contract MyContract {
      data {
          FromId address
          ToId   address
          Amount money
      }
      func conditions {
          ...
      }
      func action {
      }
  }


Cекция data
==============================

Входные данные контракта, а так же параметры формы для приема этих данных описываются в секции **data**. 
Данные перечисляются построчно: сначала указывается имя переменной (передаются только переменные, а не массивы), затем тип и опционально через пробел в двойных кавычках параметры для построения формы интерфейса:

* *hidden* - скрытый элемент формы;
* *optional* - элемент формы без обязательного заполнения;
* *date* - поле выбора даты и времени;
* *polymap* - карта с выбором координат и областей;
* *map* - карта с возможностью отметить место;
* *image* - загрузка изображений;
* *text* - ввод текста или HTML-кода в поле textarea;
* *crypt:Field* - создание и шифрование приватного ключа для адресата указанного в поле *Field*. Если указано только *crypt*, то тогда приватный ключ создастся для того пользователя, который подписывает контракт.
* *address* - поле для ввода адреса кошелька;
* *signature:contractname* - строка для вызова контракта contractname, который требует подписи (подробно рассматривается в специально разделе описания).

.. code:: js

  contract my {
    data {
        Name string 
        RequestId address
        Photo bytes "image optional"
        Amount money
        Private bytes "crypt:RequestId"
    }
    ...
  }
  
Секция conditions
==============================
в секции реализуется проверка входных данных с выводом сообщений об ошибках с помощью команд: **error**, **warning**, **info**. Все эти команды генерируют ошибку, останавливающую работу контракта, но выводят в интерфейсе различные сообщения: *критическая ошибка*, *предупреждение*, и *информативная ошибка*. Например, 

.. code:: js

  if fuel == 0 {
        error "fuel cannot be zero!"
  }
  if money < limit {
        warning Sprintf("You don't have enough money: %v < %v", money, limit)
  }
  if idexist > 0 {
        info "You have been already registered"
  }

Секция action
==============================  
Секция action содержит основной программный код контракта выполняющий получение дополнительных данных и запись результата в таблицы базы данных. Например,

.. code:: js

	action {
		DBUpdate("keys", $key_id,"-amount", $amount)
		DBUpdate("keys", $recipient,"+amount,pub", $amount, $Pub)
	}

********************************************************************************
Переменные в контракте
********************************************************************************
Входные данные контракта, описанные в секции data,  передаются в другие секции через переменные с именами данных и с символом  **$** перед ними. Возможно определить и дополнительные переменные со знаком $, которые будут глобальными в рамках выполнения контракта, включая вложенные контракты. 

В контракте доступны и предопределенные переменные, содержащие данные о транзакции, из которой был вызван данный контракт.

* *$time* - время транзакции int.
* *$ecosystem_id* - идентификатор экосистемы int.
* *$block* - номер блока, в который запечатана транзакция int.
* *$key_id* - адрес кошелька подписавшего транзакцию, если контракт вне экосистемы с ecosystem_id == 0.
* *$wallet_block* - адрес ноды, сформировавшей блок, в который входит транзакция.
* *$block_time* - время формирования блока, который содержит транзакцию с текущим контрактом int.

Предопределенные переменные доступны не только в контрактах, но и в полях Permissions, в которых указываются условия доступа к элементам приложений (таблицам, контрактам, страницам и пр.) для составления логических выражений. При этом переменные имеющие отношения к формированию блока (*$time*, *$block* и др.) имеют нулевое значение.

Предопределенная переменной *$result* используется при необходимости возвратить значение из вложенного контракта.

.. code:: js

  contract my {
    data {
        Name string 
        Amount money
    }
    func conditions {
        if $Amount <= 0 {
           error "Amount cannot be 0"
        }
        $ownerId = 1232
    }
    func action {
        DBUpdate("mytable", $ownerId, "name,amount", $Name, $Amount - 10 )
        DBUpdate("mytable2", $citizen, "amount", 10 )
    }
  }
  
********************************************************************************
Вложенные контракты
********************************************************************************
В секциях *conditions* и *action* контракта может быть вызван другой контракт с передачей ему данных из текущего контракта.  Вызов вложенного контракта возможен как непосредственно, с указанием параметров в скобках после его имени (*NameContract(Params)*), так и с помощью функции *CallContract*, для которой имя контракта передается через строковую переменную.

********************************************************************************
Редактор контрактов
********************************************************************************
Контракты создаются и редактируются в специальном редакторе программного клиента Molis. При создании нового контракта в него уже вписана типовая структура с тремя секциями *data, conditions, action*.  Редактор контрактов обеспечивает:

- написание кода контрактов (с подсветкой ключевых слов языка Simvolio);
- форматирование кода контракта;
- привязку контракта к виртуальному аккаунту, с которого будет происходить оплата его работы; 
- задание прав на редактирование контракта;
- просмотр истории изменения контрактов с возможностью восстановления прежних версий.


********************************************************************************
Язык написания контрактов Simvolio
********************************************************************************
Контракты Apla пишутся на оригинальном (разработанном командой Apla) тьюринг-полном скриптовом языке Simvolio с компиляцией в байт-код. Язык содержит необходимый набор функций, операторов и конструкций  для реализации алгоритмов обработки данных и операций со значениями базы данных. Язык Simvolio обеспечивает:

- объявление переменных с различными типами значений, а также простых и ассоциативных массивов: *var, array, map*;
- использование условной конструкции *if* и конструкции цикла *while*;
- получение значений из базы данных и запись значений в базу данных *DBFind, DBInsert, DBUpdate*;
- работу с контрактами *CallContract, ContractAccess* и др.;
- преобразование значений переменных *HexToBytes, Int, Str* и др.;
- операции со строковыми значениями *Size, Replace, Substr*.


Встроенные функции языка написания контрактов
==============================
Функции языка написания контрактов выполняют операции с данными полученными в секции *data* контракта: чтение значений из базы данных и запись значений в базу данных, преобразование типов значений и установление связи между контрактами. 

Функции не возвращают ошибок, так как все проверки на ошибки происходят автоматически.
При генерации ошибки в любой из функции, контракт прекращает свою работу и выводит описание ошибки в специальном окне.
