################################################################################
Язык написания контрактов
################################################################################
.. contents::
  :local:
  :depth: 2
  
********************************************************************************
Базовые элементы и конструкции языка
********************************************************************************

Типы значений и переменные 
==========================
Переменные языка объявляются с указанием типа значения. В очевидных случаях применяется автоматическое преобразование типов. Используются следующие типы значений:

* **bool** - булевый, принимает значения true или false;
* **bytes** - последовательность байтов;
* **int** - 64-разрядное целое число;
* **address** - 64-разрядное беззнаковое целое число;
* **array** - массив значений с произвольными типами;
* **map** - ассоциативный массив значений с произвольными типами со строковыми ключами;
* **money** - целое число типа big integer; значения хранятся в базе данных  без десятичных точек, которые вставляется при выводе в интерфейсе в соответствии с настройками валюты;
* **float** - 64-разрядное число с плавающей точкой;
* **string** - строка; указываются в двойных или обратных кавычках - "This is a line" или `This is a line`.

Все идентификаторы - имена переменных, функций, контрактов и пр. - регистрозависимы (MyFunc и myFunc - это разные имена). 

Переменные объявляются с помощью ключевого слова **var**, после которого указывается имя или имена переменных и их тип. Переменные определяются и действуют внутри фигурных скобок. При описании переменных им автоматически присваивается значение по умолчанию: для типа *bool* это *false*, для всех числовых типов - нулевые значения, для строк - пустая строка. Примеры объявления переменных: 

.. code:: js

  func myfunc( val int) int {
      var mystr1 mystr2 string, mypar int
      var checked bool
      ...
      if checked {
           var temp int
           ...
      }
  }

Массивы
==========================
Язык поддерживает два типа массивов: 

* **array** - простой массив с числовым индексом, начинающимся с 0; 
* **map** - ассоциативный массив со строковыми ключами.

Присваивание и получение элементов осуществляется указанием индекса в квадратных скобках.

.. code:: js

    var myarr array
    var mymap map
    var s string
    
    myarr[0] = 100
    myarr[1] = "This is a line"
    mymap["value"] = 777
    mymap["param"] = "Parameter"

    s = Sprintf("%v, %v, %v", myarr[0] + mymap["value"], myarr[1], mymap["param"])
    // s = 877, This is a line, Parameter

Конструкции if и while
==========================
Язык описания контрактов содержит стандартные условную конструкцию **if** и конструкцию цикла **while**, которые используются внутри функций, и контрактов. Эти конструкции могут вкладывать друг в друга. 

После ключевого слова должно идти условное выражение. Если условное выражение возвращает число, то оно считается *ложь* при значении 0. Например, *val == 0* эквивалентно *!val*, а *val != 0* тоже самое, что просто *val*. Конструкция **if** может иметь блок **else**, который выполняется если условное выражение **if** ложно. В условном выражении можно использовать операции сравнения: *<, >, >=, <=, ==, !=, а также || (ИЛИ) и && (И)*.

.. code:: js

    if val > 10 || id != $citizen {
      ...
    } else {
      ...
    }

Конструкция **while** предназначена для реализации циклов. Блок **while** выполняется до тех пор, пока его условие истинно. Для прекращения цикла внутри блока используется оператор **break**. Для исполнения блока цикла сначала используется оператор **continue**.

.. code:: js

  while true {
      if i > 100 {
         break
      }
      ...
      if i == 50 {
         continue
      }
      ...
  }

Кроме условных выражений, язык поддерживает стандартные арифметические действия: +,-,*,/
Если в качестве условия вы укажете переменную типа **string** или **bytes**, то условие будет истино, если длина строки (bytes) больше нуля. На пустой строке условие будет ложь.


Функции
==========================
Функция определяется с помощью ключевого слова **func**, после которого указывается имя функции, в круглых скобках через запятую передаваемые параметры с указанием типа, после закрывающей скобки - тип возвращаемого значения. Тело функции заключается в фигурные скобки. Если функция не имеет параметров, то круглые скобки можно опустить. Для возврата значения из функции используется ключевое слово **return**.

.. code:: js

  func myfunc(left int, right int) int {
      return left*right + left - right
  }
  func test int {
      return myfunc(10, 30) + myfunc(20, 50)
  }
  func ooops {
      error "Ooops..."
  }

Ошибки при выполнении любой функции обрабатываются автоматически вызывая остановку выполнения контракта и вывод соответствующего сообщения.

Имеется возможность передавать функции неопределенное количество параметров. Для этого у последнего параметра необходимо вместо типа указать **...**. В этом случае, последний параметр будет иметь тип *array* и содержать все, начиная с данного параметра, указанные при вызове переменные. Можно передавать переменные любых типов, но вы должны самостоятельно предотвращать конфликты выполнения из-за несовпадений типов.

.. code:: js

  func sum(out string, values ...) {
      var i, res int
      
      while i < Len(values) {
         res = res + values[i]
         i = i + 1
      }
      Println(out, res)
  }

  func main() {
     sum("Sum:", 10, 20, 30, 40)
  }

Рассмотрим ситуацию, когда функция может иметь много параметров, но часто при вызове необходимо указывать только некоторые из них. В этом случае,опциональные параметры можно описывать следующим образом **func myfunc(name string).Param1(param string).Param2(param2 int) {...}**. При вызове вы можете в любом порядке указывать только некоторые из дополнительных параметров **myfunc("name").Param2(100)**. В теле функции вы как обычно можете обращаться к этим переменным. Если при вызове расширенный параметр не указан, то он принимает значение по умолчанию, например, пустая строка для строки и ноль для числа. Также, следует заметить, что можно указывать несколько расширенных параметров и использовать **...** - **func DBFind(table string).Where(request string, params ...)** и вызов **DBFind("mytable").Where("id > ? and type = ?", myid, 2)**

.. code:: js
 
    func DBFind(table string).Columns(columns string).Where(format string, tail ...)
             .Limit(limit int).Offset(offset int) string  {
       ...
    }
     
    func names() string {
       ...
       return DBFind("table").Columns("name").Where("id=?", 100).Limit(1)
    }

Предопределенные значения
==========================
При выполнении контракта доступны следующие переменные.

* **$key_id** - числовой идентификатор (int64) аккаунта, от которого подписана транзакциюя.
* **$ecosystem_id** - идентификатор экосистемы, в которой была создана транзакция. 
* **$type** - идентификатор вызываемого контракта. Если, например, контракт вызвал другой контракт, то здесь будет хранится идентификатор оригинального контракта.
* **$time** - время указанное в транзакции в формате Unix.
* **$block** - номер блока, в котором запечаталась данная транзакция. 
* **$block_time** - время указанное в блоке. 
* **$block_key_id** - числовой идентифкатор (int64) ноды, которая подписала блок. 
* **$auth_token** - токен авторизации, который можно использовать в VDE контрактах, например, при вызове контрактов через api c помощью функции **HTTPRequest**.

.. code:: js

	var pars, heads map
	heads["Authorization"] = "Bearer " + $auth_token
	pars["vde"] = "false"
	ret = HTTPRequest("http://localhost:7079/api/v2/node/mycontract", "POST", heads, pars)

Предопределенные переменные доступны не только в контрактах, но и в полях Permissions, в которых указываются условия доступа к элементам приложений (таблицам, контрактам, страницам и пр.) для составления логических выражений. При этом переменные имеющие отношения к формированию блока (*$time*, *$block* и др.) имеют нулевое значение.

Предопределенная переменной *$result* используется при необходимости возвратить значение из вложенного контракта.

################################################################################
Встроенные функции языка написания контрактов
################################################################################

Функции языка написания контрактов выполняют операции с данными полученными в секции data контракта: чтение значений из базы данных и запись значений в базу данных, преобразование типов значений и установление связи между контрактами. 

Функции не возвращают ошибок, так как все проверки на ошибки происходят автоматически.
При генерации ошибки в любой из функции, контракт прекращает свою работу и выводит описание ошибки в специальном окне.


********************************************************************************
Получение значений из базы данных
********************************************************************************

DBFind(table string) [.Columns(columns string)] [.Where(where string, params ...)] [.WhereId(id int)] [.Order(order string)] [.Limit(limit int)] [.Offset(offset int)] [.Ecosystem(ecosystemid int)] array
==========================
Функция получает данные из таблицы базы данных в соответствии с указанным запросом. Возвращается массив *array* состоящий из ассоциативных массивов *map*. Для получения map от первого элемента можно использовать дополнительно функцию **.Row()**, а для получения конкретного значения функцию **.One(column string)**.

* *table* - имя таблицы.
* *сolumns* - список возвращаемых колонок. Если не указано, то возвратятся все колонки. 
* *Where* - условие поиска. Например, *.Where("name = 'John'")* или  *.Where("name = ?", "John")*
* *id* - поиск по идентификатору. Достаточно указать значение идентификатора.  Например, *.WhereId(1)*
* *order* - поле, по которому нужно отсортировать. Пол умолчанию, сортируется по *id*.
* *limit* - количество возвращаемых записей. По умолчанию, 25. Максимально возможно количество - 250.
* *offset* - смещение возвращаемых записей.
* *ecosystemid* - идентификатор экосистемы. По умолчанию, берутся данные из таблицы в текущей экосистеме.

.. code:: js

   var i int
   ret = DBFind("contracts").Columns("id,value").Where("id> ? and id < ?", 3, 8).Order("id")
   while i < Len(ret) {
       var vals map
       vals = ret[0]
       Println(vals["value"])
       i = i + 1
   }

Row(list array) map
==========================
Функция возвращает первый ассоциативный массив *map* из массива *list*. Если список *list* пустой, то результат вернет пустой *map*. Может использоваться одновременно с функцией DBFind, в этом случае параметр не указывается. 

* *list* - массив map, возвращаемый функцией **DBFind**.

.. code:: js

   var ret map
   ret = DBFind("contracts").Columns("id,value").WhereId(10).Row()
   Println(ret)

One(list array, column string) string
==========================
Функция возвращает значение колонки с именем *column* из первой записи массива *list*. Если список *list* пустой, то в результате вернется nil. Может использоваться одновременно с функцией DBFind, в этом случае параметр *list* не указывается. 

* *list* - массив map, возвращаемый функцией **DBFind**.
* *column* - имя возвращаемой колонки.

.. code:: js

   var ret string
   ret = DBFind("contracts").Columns("id,value").WhereId(10).One("value")
   if ret != nil {
      Println(ret)
   }

DBRow(table string) [.Columns(columns string)] [.Where(where string, params ...)] [.WhereId(id int)] [.Order(order string)] [.Ecosystem(ecosystemid int)] map
==========================
Функция возвращает ассоциативный массив *map*, с данными полученными из таблицы базы данных в соответствии с указанным запросом. * *table* - имя таблицы.

* *table* - имя таблицы.
* *сolumns* - список возвращаемых колонок. Если не указано, то возвратятся все колонки. 
* *Where* - условие поиска. Например, *.Where("name = 'John'")* или  *.Where("name = ?", "John")*
* *id* - идентификатор возвращаемой строки.  Например, *.WhereId(1)*
* *order* - поле по которому производится сортировка; по умолчанию, сортируется по *id*.
* *ecosystemid* - идентификатор экосистемы; по умолчанию,  id текущей экосистемы.

.. code:: js

   var ret map
   ret = DBRow("contracts").Columns("id,value").Where("id = ?", 1)
   Println(ret)
	
EcosysParam(name string) string
==============================
Функция возвращает значение указанного параметра из настроек экосистемы (таблица *parameters*).

* *name* - имя получаемого параметра.

.. code:: js

    Println( EcosysParam("gov_account"))
	
LangRes(label string, lang string) string
==============================
Функция возвращает языковой ресурс с именем label для языка lang, заданного двухсимвольным кодом, например, *en,fr,ru*. Если для указанного языка нет ресурса, то возвращается значение на английском языке.

* *label* - имя языкового ресурса;
* *lang* - двухсимвольный код языка;

.. code:: js

    warning LangRes("confirm", $Lang)
    error LangRes("problems", "de")
	
********************************************************************************
Изменение значений в таблицах 
********************************************************************************

DBInsert(tblname string, params string, val ...) int
==============================
Функция добавляет запись в указанную таблицу и возвращает **id** вставленной записи.

* *tblname* - имя таблицы в базе данных.
* *params* - список через запятую имен колонок, в которые будут записаны перечисленные в **val** значения. 
* *val* - список через запятую значений для перечисленных в **params** столбцов; значения могут иметь строковый или числовой тип.

.. code:: js

    DBInsert("mytable", "name,amount", "John Dow", 100)

DBUpdate(tblname string, id int, params string, val...)
==============================
Функция изменяет значения столбцов в таблице в записи с указанным **id**.

* *tblname* - имя таблицы в базе данных.
* *id* - идентификатор **id** изменяемой записи.
* *params* - список имен изменяемых колонок; перечисляются через запятую.
* *val* - список значений для указанных столбцов перечисленных в **params**; могут иметь строковый или числовой тип.

.. code:: js

    DBUpdate("mytable", myid, "name,amount", "John Dow", 100)

DBUpdateExt(tblname string, column string, value (int|string), params string, val ...)
==============================
Функция обновляет столбцы в записи, у которой колонка имеет заданное значение. Таблица должна иметь индекс по указанной колонке.

* *tblname* - имя таблицы в базе данных.
* *column* - имя колонки, по которой будет идти поиск записи.
* *value* - значение для поиска записи в колонке.
* *params* - список имен колонок, в которые будут записаны значения указанные в **val**; перечисляются через запятую.
* *val* - список значений для записи в колонки перечисленные в  **params**; могут иметь строковый или числовой тип.

.. code:: js

    DBUpdateExt("mytable", "address", addr, "name,amount", "John Dow", 100)

********************************************************************************
Работа с контрактами и языком
********************************************************************************

CallContract(name string, params map)
==============================
Функция вызывает контракт по его имени. В передаваемом массиве должны быть перечислены все параметры, указанные в section data контракта. Функция возвращает значение, которое было присвоено переменной **$result** в контракте.

* *name* - имя вызываемого контракта.
* *params* - ассоциативный массив с входными данными для контракта.

.. code:: js

    var par map
    par["Name"] = "My Name"
    CallContract("MyContract", par)

ContractAccess(name string, [name string]) bool
==============================
Функция проверяет, совпадает ли имя выполняемого контракта с одним из имен, перечисленных в параметрах. Как правило используется для контроля доступа контрактов к таблицам. Функция прописывается в полях *Permissions* при редактировании колонок таблицы или в полях  *Insert* и *New Column* в разделе *Table permission*.

* *name* - имя контракта.

.. code:: js

    ContractAccess("MyContract")  
    ContractAccess("MyContract","SimpleContract") 
    
ContractConditions(name string, [name string]) bool
==============================
Функция вызывает секцию **conditions** из контрактов с указанными именами. У таких контрактов блок *data* должен быть пустой. Если секция *conditions* выполнилась без ошибок, то возвращается *истина*. Если в процессе выполнения сгенерировалась ошибка, то родительский контракт также завершится с данной ошибкой. Эта функция, как правило, используется для контроля доступа контрактов к таблицам и может вызываться в полях *Permissions* при редактировании системных таблиц.

* *name* - имя контракта.

.. code:: js

    ContractConditions("MainCondition")  

EvalCondition(tablename string, name string, condfield string) 
==============================
Функция берет из таблицы *tablename* значение поля *condfield* из записи с полем *'name'*, которое равно параметру *name*, и проверяет выполнено ли условие полученное из поля *condfield* или нет. Если условие не выполнено, то генерируется ошибка, с которой и завершается вызывающий контракт.

* *tablename* - имя таблица.
* *name* - значение для поиска по полю 'name'.
* *condfield* - имя поля где хранится условие, которое необходимо будет проверить.

.. code:: js

    EvalCondition(`menu`, $Name, `condition`)  

ValidateCondition(condition string, state int) 
==============================
Функция пытается скомпилировать условие, указанное в параметре *condition*. Если в процессе компиляции условия возникнет ошибка, то будет сгенерирована ошибка и вызывающий контракт закончит свою работу. Данная функция предназначена для проверки правильности условий при их изменении.

* *condition* - проверяемое условие.
* *state* - идентифкатор государства. Укажите ноль, если проверка для глобальных условий.

.. code:: js

    ValidateCondition(`ContractAccess("@0MyContract")`, 0)  

********************************************************************************
Операции со значениями переменных
********************************************************************************
    
AddressToId(address string) int
==============================
Функция возвращает идентификационный номер гражданина по строковому значению адреса его кошелька. Если указан неверный адрес, то возвращается 0.

* *address* - адрес кошелька в формате XXXX-...-XXXX или в виде числа.

.. code:: js

    wallet = AddressToId($Recipient)
    
IdToAddress(id int) string
==============================
Функция возвращает адрес кошелька по идентификационному номеру. Если указан неверный айди, то возвращается 'invalid'.

* *id* - идентификационный номер в виде числа.

.. code:: js

    $address = IdToAddress($id)

Contains(s string, substr string) bool
==============================
Функция возвращает true, если строка *s* содержит подстроку *substr*.

* *s* - проверяема строка.
* *substr* - подстрока, которая ищется в указанной строке.

.. code:: js

    if Contains($Name, `my`) {
    ...
    }    

Float(val int|string) float
==============================
Функция преобразует целое число *int* или *string* в число с плавающей точкой.

* *val* - целое число или строка.

.. code:: js

    val = Float("567.989") + Float(232)

HasPrefix(s string, prefix string) bool
==============================
Функция возвращает true, если строка начинается с указанной подстроки *prefix*.

* *s* - проверяема строка.
* *prefix* - проверяемый префикс у данной строки.

.. code:: js

    if HasPrefix($Name, `my`) {
    ...
    }

HexToBytes(hexdata string) bytes
==============================
Функция преобразует строку с шестнадцатеричной кодировкой в значение  типа *bytes* (последовательность байт).

* *hexdata* - строка, содержащая шестнадцатеричную запись.

.. code:: js

    var val bytes
    val = HexToBytes("34fe4501a4d80094")

Join(in array, sep string) string
==============================
Функция объединяет элементы массива *in* в строку с указанным разделителем *sep*.

* *in* - имя массива типа *array*, элементы которого необходимо объединить.
* *sep* - строка-разделитель.

.. code:: js

    var val string, myarr array
    myarr[0] = "first"
    myarr[1] = 10
    val = Join(myarr, ",")

Random(min int, max int) int
==============================
Функция возвращает случайное число в диапазоне между min и max (min <= result < max). min и max должны быть положительными числами.

* *min* - минимальное значение случайного числа;
* *max* - Случайное значение будет меньше этого числа;

.. code:: js

    i = Random(10,5000)

Split(in string, sep string) array
==============================
Функция возвращает массив, полученный из элементов строки *in*, при ее разбивании в соответствии с разделителем *sep*.
* *in* - строка, которую необходимо разбить.
* *sep* - строка-разделитель.

.. code:: js

    var myarr array
    myarr = Split("first,second,third", ",")

Int(val string) int
==============================
Функция преобразует строковое значение в целое число.

* *val* - строка содержащая число.

.. code:: js

    mystr = "-37763499007332"
    val = Int(mystr)

Len(val array) int
==============================
Функция возвращает количество элементов в указанном массиве.

* *val* - массив типа *array*.

.. code:: js

    if Len(mylist) == 0 {
      ...
    }

PubToID(hexkey string) int
==============================
Функция возвращает адрес кошелька по публичному ключу в шестнадцатеричной кодировке.

* *hexkey* - публичный ключ в шестнадцатеричном виде.

.. code:: js

    var wallet int
    wallet = PubToID("fa5e78.....34abd6")

Replace(s string, old string, new string) string
==============================
Функция заменять в строку *s* все вхождения строки *old* на строку *new* и возвращает полученный результат.

* *s* - исходная строка.
* *old* - заменяемая строка.
* *new* - новая строка.

.. code:: js

    s = Replace($Name, `me`, `you`)

Size(val string) int
==============================
Функция возвращает размер указанной строки.

* *val* - строка, для которой нужно вычислить размер.

.. code:: js

    var len int
    len = Size($Name)

Sha256(val string) string
==============================
Функция возвращает хэш **SHA256** от указанной строки.

* *val* - входящая строка, для которой нужно вычислить хэш **Sha256**.

.. code:: js

    var sha string
    sha = Sha256("Test message")

Sprintf(pattern string, val ...) string
==============================
Функция формирует строку на основе указанного шаблона и параметров, можно использовать *%d (число), %s (строка), %f (float), %v* (для любых типов).

* *pattern* - шаблон для формирования строки.

.. code:: js

    out = Sprintf("%s=%d", mypar, 6448)



Str(val int|float) string
==============================
Функция преобразует числовое значение типа *int* или *float* в строку.

* *val* - целое или число с плавающей точкой.

.. code:: js

    myfloat = 5.678
    val = Str(myfloat)

Substr(s string, offset int, length int) string
==============================
Функция возвращает подстроку от указанной строки начиная со смещения *offset* (cчитается с 0) и длиной *length*. В случае некорректных смещений или длины возвращается пустая строка. Если сумма смещения и *length* больше размера строки, то возвратится подстрока от смещения до конца строки.

* *val* - строка.
* *offset* - смещение подстроки.
* *length* - размер подстроки.

.. code:: js

    var s string
    s = Substr($Name, 1, 10)

UpdateLang(name string, trans string)
==============================
Функция обновляет языковой ресурс в памяти. Используется в транзакциях, которые меняют языковые ресурсы.

* *name* - имя языкового ресурса.
* *trans* - ресурс с переводами.

.. code:: js

    UpdateLang($Name, $Trans)


********************************************************************************
Работа с системными таблицами
********************************************************************************

SysParamString(name string) string
==============================
Функция возвращает значение указанного системного параметра.

* *name* - имя параметра;

.. code:: js

    url = SysParamString(`blockchain_url`)

SysParamInt(name string) int
==============================
Функция возвращает значение указанного системного параметра в виде числа.

* *name* - имя параметра;

.. code:: js

    maxcol = SysParam(`max_columns`)

UpdateSysParam(name, value, conditions string)
==============================
Функция обновляет значение и условие системного параметра. Если значение или условие менять не нужно, то следует в соответствующем параметре указать пустую строку.

* *name* - имя параметра;
* *value* - новое значение параметра;
* *conditions* - новое условие изменения параметра;

.. code:: js

    UpdateSysParam(`fuel_rate`, `400000000000`, ``)

********************************************************************************
Работа с PostgreSQL
********************************************************************************

Функции не дают возможности напрямую отправлять запросы с select, update и т.д., но они позволяют использовать возможности и функции PostgrеSQL при получении значений и описания условий where в выборках. Это относится в том числе и к функциям по работе с датами и временем. Например, необходимо сравнить колонку *date_column* и текущее время. Если *date_column* имеет тип timestamp, то выражение будет следующим *date_column > now()*, а если *date_column* хранит время в Unix формате в виде числа, то тогда выражение будет *to_timestamp(date_column) > now()*. 

.. code:: js

    to_timestamp(date_column) > now()
    date_initial < now() - 30 * interval '1 day'

Рассмотрим ситуацию, когда у нас есть значение в формате Unix и необходимо записать его в поле имеющее тип *timestamp*. В этом случае, при перечислении полей, перед именем данной колонки необходимо указать **timestamp**. 

.. code:: js

   DBInsert("mytable", "name,timestamp mytime", "John Dow", 146724678424 )

Если же вы имеете строковое значение времени и вам нужно записать его в поле с типом *timestamp*. В этом случае,  **timestamp** необходимо указать перед самим значением. 

.. code:: js

   DBInsert("mytable", "name,mytime", "John Dow", "timestamp 2017-05-20 00:00:00" )
   var date string
   date = "2017-05-20 00:00:00"
   DBInsert("mytable", "name,mytime", "John Dow", "timestamp " + date )
   DBInsert("mytable", "name,mytime", "John Dow", "timestamp " + $txtime )

********************************************************************************
Функции для VDE
********************************************************************************

Данные функции можно использовать только в контрактах для virtual dedicated ecosystems.

HTTPRequest(url string, method string, heads map, pars map) string
==============================
Функция отправляет HTTP запрос на указанный адрес.

* *url* - адрес, куда будет отправлен запрос.
* *method* - метод запроса - GET или POST.
* *heads* - массив данных для формирования заголовка.
* *pars* - параметры.

.. code:: js

	var ret string 
	var pars, heads, json map
	heads["Authorization"] = "Bearer " + $auth_token
	pars["vde"] = "true"
	ret = HTTPRequest("http://localhost:7079/api/v2/content/page/default_page", "POST", heads, pars)
	json = JSONToMap(ret)

HTTPPostJSON(url string, heads map, pars string) string
==============================
Функция подобна функции *HTTPRequest*, но она отправляет *POST* запрос и параметры передаются одной строкой.

* *url* - адрес, куда будет отправлен запрос.
* *heads* - массив данных для формирования заголовка.
* *pars* - параметр в виде json строки.

.. code:: js

	var ret string 
	var heads, json map
	heads["Authorization"] = "Bearer " + $auth_token
	ret = HTTPPostJSON("http://localhost:7079/api/v2/content/page/default_page", heads, `{"vde":"true"}`)
	json = JSONToMap(ret)



