################################################################################
Компилятор и виртуальная машина
################################################################################

В данном разделе рассматривается код организация и работа кода в директории packages/script, который относится к компиляции и
работе виртуальной машины языка Simvolio. Документация предназначена в первую очередь для разработчиков.

Работа с контрактами организована следующим образом. Контракты, функции пишутся на языке Simvolio и хранятся в 
таблицах contracts в экосистемах. При запуске программы происходит чтение исходного кода из базы данных и 
компиляция его в байт-код. При добавлении или изменении контрактов и записи их в блокчейн, обновляемые 
данные компилируются и добавляется/обновляется соответствующий байт-код в виртуальной машине. 
Физически байт код никуда не сохраняется, при выходе из программы и новом запуске компиляция происходит заново. 
Виртуальная машина представляет из себя набор объектов - контракты, функции, типы и т.п. Весь исходный код, 
описанный в таблице contracts у всех экосистем, компилируется в строгой последовательности в одну 
виртуальную машину и на всех нодах состояние виртуальной машины одно и тоже. При вызове контракта сама 
виртуальная машина никак не изменяет своего состояния. Любое выполнение контракта или вызов функции происходят 
на отдельном runtime стеке, который создается при каждом внешнем вызове. Каждая экосистема может иметь так 
называемую виртуальную экосистему, которая работает со своими таблицами вне блокчейна, в рамках одной ноды, и 
апрямую не может оказывать влияния на блокчейн или другие виртуальные экосистемы. В этом случае нода, которая 
хостит такую виртуальную экосистему. компилирует её контракты и создает для неё свою виртуальную машину.

********************************************************************************
Виртуальная машина
********************************************************************************
Рассмотрим как организована виртуальная машина в памяти.

type VM struct {
   Block         
   ExtCost func(string) int64
   FuncCallsDB map[string]struct{}
   Extern bool 
}

Block - это сама главная структура, которая содержит всю информацию.
ExtCost - функция которая возвращает стоимость выполнения внешних golang функций.
FuncCallsDB - map имен golang функций, которые возвращают  стоимость выполнения первым параметром. Это функции работы с БД, которые вычисляют стоимость с помощью EXPLAIN.
Extern - при создании ВМ устанавливается в true и при компиляции кода не требует наличие вызываемого контракта. То есть дает вызывать контракт, который будет определен в дальнейшем.

Виртуальная машина представляет из себя дерево из объектов типа Block. По сути блок - это самостоятельная единица, содержащая какой-то байт-код. Простыми словами - всё что в языке заключается в фигурные скобки является блоком. Например,

func my() {
     if true {
          while false {
               ...
           }
     }
} 
создает блок с функцией в котором блок с if и в котором, в свою очередь, блок с while.

type Block struct {
    Objects map[string]*ObjInfo
    Type int
    Owner *OwnerInfo
    Info interface{}
    Parent *Block
    Vars []reflect.Type
    Code ByteCodes
    Children Blocks
}

Objects - map внутренних объектов типа указателей на ObjInfo. Если, к примеру, в блоке имеется переменная, то мы можем быстро получить информацию о ней по имени.
Type - Типа блока. функций и контрактов равен ObjFunc и ObjContract.
Owner - ссылка на структуру OwnerInfo, которая содержит информацию о владельце компилируемого контракта.Указывается при компиляции контрактов или получается при загрузке из таблице contracts.
Info - Содержит непосредственно информацию об объекте и зависит от типа блока.
Parent - указатель на родительский блок.
Vars - массив с типами переменных данного блока.
Code - непосредственно байт-код, который начнет исполнятся при передаче управления данном блоку. Например, в случае вызова функции или тело цикла.
Children - массив дочерних блоков. Например, вложенные функции, циклы, условные операторы.

Рассмотрим еще одну важную структуру ObjInfo.

type ObjInfo struct {
   Type int
   Value interface{}
}

Type - Тип объекта может принимать одно и следующих значений: 

ObjContract - контракт
ObjFunc - функция
ObjExtFunc - внешняя golang функция
ObjVar - переменная
ObjExtend - переменная $name.

Value - содержит соответствующую структуру для каждого типа. 

type ContractInfo struct {
    ID uint32
    Name string
    Owner *OwnerInfo
    Used map[string]bool
    Tx *[]*FieldInfo
    Settings map[string]interface{}
}

ID - идентификатор контракта. Это значение указывается в блокчейне для вызове контракта.
Name - имя контракта.
Owner - дополнительная информация о контракте.
Used - map имен контрактов, которые вызывается внутри.
Tx - массив данных, которые описаны в разделе data у контракта.
type FieldInfo struct {
       Name string
      Type reflect.Type
      Tags string
}
где Name - имя поля, Type - тип, Tags - дополнительные теги для поля.
Settings - map значений, которые описываются в разделе settings у контракта.
Как видно информация во многом дублируется со структурой блок. Это можно считать архитектурным недостатком, от которого желательно избавиться.

Для типа ObjFunc поле Value содержит структуру FuncInfo
type FuncInfo struct {
     Params []reflect.Type
     Results []reflect.Type
    Names *map[string]FuncName
    Variadic bool
    ID uint32
}

Params - массив типов параметров.
Results - массив возвращаемых типов.
Names - map данных для tail функций. Например, DBFind().Columns().
type FuncName struct {
   Params []reflect.Type
   Offset []int
   Variadic bool
}
Params - массив типов параметров
Offset - массив смещений для этих переменных. По сути, все параметры, которые передаются в функциях через точку являются переменными, которым могут быть присвоены инициализирующие значения.
Variadic - true если tail описание может иметь переменной количество параметров.

Variadic - true если у функции может быть  переменной число параметров.
ID - идентификатор функции.

Для типа ObjExtFunc поле Value содержит структуру ExtFuncInfo. Она описывает функции на golang.
type ExtFuncInfo struct {
   Name string
   Params []reflect.Type
   Results []reflect.Type
   Auto []string
   Variadic bool
   Func interface{}
}
Совпадающие параметры как у структуры FuncInfo.
Auto - массив переменных, которые дополнительно передаются в golang функций, если они есть. Например, переменные sc типа SmartContract.
Func - golang функция.

Для типа ObjVar поле Value содержит структуру VarInfo
type VarInfo struct {
   Obj *ObjInfo
   Owner *Block
}
ObjInfo - информация о типе и значении переменной.
Owner - указатель на блок -хозяина.

Для объектов типа ObjExtend поле Value содержит строку с именем переменной или функции.

Команды виртуальной машины
Идентификаторы команд виртуальной машины описаны в файле cmds_list.go. Байт-код представляет из себя последовательность структур типа ByteCode.

type ByteCode struct {
   Cmd uint16
   Value interface{}
}

В поле Cmd хранится идентификатор команды, а в поле Value сопутствующее значение. Как правило команды осуществляют операции над конечными элементами стека, и если необходимо, то записывают туда результирующее значение.

cmdPush - поместить значение из поля Value в стек. Например, используется для помещения в стек чисел, строк.
cmdVar - поместить значение переменной в стек. Value содержит указатель на структуру VarInfo c информацией о переменной.
cmdExtend - поместить в стек значение внешней переменной, они начинаются с $. Value содержит строку с именем переменной.
cmdCallExtend - вызвать внешнюю функцию, их имена начинаются с $. Из стека будут взяты параметры функции, а результат(ы) функции будут помещены в стек. Value содержит имя функции.
cmdPushStr - Поместить строку из Value в стек
cmdCall - вызвать функцию виртуальной машины.Value содержит указать на структуру ObjInfo. Эта команда применима как для ObjExtFunc golang функций, так и для ObjFunc Simvolio функций. При вызове функции передаваемые параметры берутся из стека, а результирующие значения возвращаются в стек. 
cmdCallVari - аналогично команде cmdCall вызывает функцию виртуальной машины, но эта команда применяется для вызова функций с переменным числом параметров.
cmdReturn - служит для выхода из функции. При этом возвращаемые значения помещаются в стек. Value не используется.
cmdIf - передает управление байткоду в структуре Block, указатель на который передан в поле Value. Управление передается только, если вызов функции valueToBool c крайним элементом стека возвращает true.  В противном случае, управление передается следующей команде.
cmdElse - команда работает аналогично команде cmdIf, но управление указанному блоку передается только, если valueToBool c крайним элементом стека возвращает false.
cmdAssignVar - получаем из Value список переменных типа VarInfo, которым будет присваиваться значение с помощью команды cmdAssign.
cmdAssign - присвоить переменным полученным командой cmdAssignVar значения из стека.
cmdLabel - определяет метку, куда будет возвращаться управление в цикле while.
cmdContinue - команда передает управление на метку cmdLabel. Осуществляет новую итерацию цикла. Value не используется. 
cmdWhile - проверяет крайний элемент стека с помощью valueToBool и вызывает Block передаваемые в поле Value, если значение true.
cmdBreak - осуществляет выход из цикла.
cmdIndex - получение в стек значение map или array по индексу. Value не используется.  (map|array) (index value) => ( map|array[index value] )
cmdSetIndex - присвоить элементу map или array крайнее значение стека. Value не используется. (map|array) (index value) (value) => (map|array)
cmdFuncName - добавляет параметры , которые передаются с помощью  последовательных описаний через точку  func name Func(...).Name(...). 
cmdError - команда создается прекращает работу контракта или функции с ошибкой, которая была указана в error, warning или info.

Ниже идет команды непосредственно для работы со стеком. Поле Value в них не используется. Следует заметить, что сейчас нет полностью автоматического приведения типов. Например, string + float|int|decimal => float|int|decimal, float + int|str => float,  но int + string => runtime error.
cmdNot - логическое отрицание (val) => (!valueToBool(val))
cmdSign - смена знака. (val) => (-val)
cmdAdd -  сложение. (val1)(val2) => (val1+val2)
cmdSub - вычитание. (val1)(val2) => (val1-val2)
cmdMul - умножение.  (val1)(val2) => (val1*val2)
cmdDiv - деление. (val1)(val2) => (val1/val2)
cmdAnd - логическое И.  (val1)(val2) => (valueToBool(val1) && valueToBool(val2))
cmdOr - логическое ИЛИ.  (val1)(val2) => (valueToBool(val1) || valueToBool(val2))
cmdEqual - сравнение на равенство, возвращается bool. (val1)(val2) => (val1 == val2)
cmdNotEq - сравнение на неравенство, возвращается bool. (val1)(val2) => (val1 != val2)
cmdLess - сравнение на меньше, возвращается bool. (val1)(val2) => (val1 < val2)
cmdNotLess -  сравнение на больше или равно, возвращается bool. (val1)(val2) => (val1 >= val2)
cmdGreat - сравнение на больше, возвращается bool. (val1)(val2) => (val1 > val2)
cmdNotGreat  -  сравнение на меньше или равно, возвращается bool. (val1)(val2) => (val1 <= val2)

Как уже было замечено ранее, выполнение байт-кода не влияет на виртуальную машину. Это, например, позволяет одновременно запускать различные функции и контракты в рамках одной виртуальной машины. Для запуска функций и контрактов, а также любых выражений и байт-кода используется структура Runtime.

type RunTime struct {
   stack []interface{}
   blocks []*blockStack
   vars []interface{}
   extend *map[string]interface{}
   vm *VM
   cost int64
   err error
}

stack - стек, на которым происходит выполнение байт-кода.
blocks - стек вызовов блоков.
type blockStack struct {
     Block *Block
     Offset int
}
Block - указатель на выполняемый блок.
Offset - смещение последней выполняемой команды в байт-коде указанного блока.
vars - стек значений переменных. При вызове байт-кода в блоке, его переменные добавляются в этот стек переменных. После выхода из блока, размер стека переменных возвращается к предыдущему значению.
extend -указатель на map со значениями внешних переменных ($name).
vm - указатель на виртуальную машину.
cost - результирующая стоимость выполнения.
err - ошибка выполнения, если она была.

Выполнение байт-кода происходит в функции RunCode. Она содержит цикл, который выполняет соответствующие действия для каждой команды бай-кода. Перед началом обработки байт-кода,мы должны инициализировать необходимые данные.
Здесь мы добавляем наш блок в
rt.blocks = append(rt.blocks, &blockStack{block, len(rt.vars)})

Далее мы получаем информацию о параметрах "хвостовых" функциях, которые должны находится в последнем элементе стека.
var namemap map[string][]interface{}
if block.Type == ObjFunc && block.Info.(*FuncInfo).Names != nil {
    if rt.stack[len(rt.stack)-1] != nil {
        namemap = rt.stack[len(rt.stack)-1].(map[string][]interface{})
    }
    rt.stack = rt.stack[:len(rt.stack)-1]
}

Далее мы должны инициализировать начальными значениями все переменные, которые определены в данном блоке. 
start := len(rt.stack)
varoff := len(rt.vars)
for vkey, vpar := range block.Vars {
    rt.cost--
   var value interface{}

Так как у нас переменные функции тоже являются переменными, то мы должны взять их из последних элементов стека в том же порядке, в каком они описаны в самой функции.
    if block.Type == ObjFunc && vkey < len(block.Info.(*FuncInfo).Params) {
        value = rt.stack[start-len(block.Info.(*FuncInfo).Params)+vkey]
    } else {
Здесь мы инициализируем локальные переменные начальными значениями.
        value = reflect.New(vpar).Elem().Interface()
        if vpar == reflect.TypeOf(map[string]interface{}{}) {
             value = make(map[string]interface{})
       } else if vpar == reflect.TypeOf([]interface{}{}) {
            value = make([]interface{}, 0, len(rt.vars)+1)
       }
    }
    rt.vars = append(rt.vars, value)
}
Далее нам необходимо обновить значения у параметров-переменных, которые были переданы в "хвостовых" функциях.
if namemap != nil {
  for key, item := range namemap {
    params := (*block.Info.(*FuncInfo).Names)[key]
    for i, value := range item {
         if params.Variadic && i >= len(params.Params)-1 {
Если у нас может передаваться переменное количество параметров, то мы объединяем их в одну переменную массив.
               off := varoff + params.Offset[len(params.Params)-1]
               rt.vars[off] = append(rt.vars[off].([]interface{}), value)
         } else {
              rt.vars[varoff+params.Offset[i]] = value
        }
    }
 }
}

После этого нам остается только сдвинуть стек убрав из вершины значения, которые были переданы как параметры функции. Их значения мы уже скопировали выше в массив переменных.
if block.Type == ObjFunc {
     start -= len(block.Info.(*FuncInfo).Params)
}

После окончания работы цикла по выполнению команд байт-кода мы должны корректно очистить стек.
last := rt.blocks[len(rt.blocks)-1]
убираем из стека блоков текущий блок
rt.blocks = rt.blocks[:len(rt.blocks)-1]
if status == statusReturn {
В случае успешного выхода из выполняемой функции мы добавляем к предыдущему концу стека возвращаемые значения.
    if last.Block.Type == ObjFunc {
        for count := len(last.Block.Info.(*FuncInfo).Results); count > 0; count-- {
           rt.stack[start] = rt.stack[len(rt.stack)-count]
           start++
       }
      status = statusNormal
    } else {
Как видно если у нас выполняется не функция, то мы не восстанавливаем состояние стека, а выходим из функции как есть. Дело в том, что блоком  с байт-кодом также являются циклы и условные конструкции, которые уже выполняются внутри какой-то функции.
      return
    }
}
rt.stack = rt.stack[:start]

Рассмотрим другие функции для работы с виртуальной машиной. Любая виртуальная машина создается с помощью функции NewVM. В каждую виртуальную машину сразу добавляются три функции ExecContract, CallContract и Settings. Добавление происхходит с помощью функции Extend.
for key, item := range ext.Objects {
      fobj := reflect.ValueOf(item).Type()

Мы перебираем все передаваемые объекты и смотрим только функции. 
     switch fobj.Kind() {
         case reflect.Func:
По информации, полученной о функции мы заполняем структуру ExtFuncInfo и добавляем её в map Objects верхнего уровня по ее имени.
               data := ExtFuncInfo{key, make([]reflect.Type, fobj.NumIn()),
                            make([]reflect.Type, fobj.NumOut()), make([]string, fobj.NumIn()),
                            fobj.IsVariadic(), item}
              for i := 0; i < fobj.NumIn(); i++ {

У нас есть так называемые Auto параметры. Как правило, это первый параметр, например sc *SmartContract или rt *Runtime. Мы не можем передавать их из языка Simvolio, но они нам необходимы при выполнении некоторых golang функций.Поэтому мы указываем какие переменные будут автоматически подставляться в момент вызова функции. В данном случае,  функции ExecContract, CallContract имеют такой параметр rt *Runtime.
                     if isauto, ok := ext.AutoPars[fobj.In(i).String()]; ok {
                     data.Auto[i] = isauto
               }
Заполняем информацию о параметрах
              data.Params[i] = fobj.In(i)
          }
и о типах возвращаемых значений
          for i := 0; i < fobj.NumOut(); i++ {
              data.Results[i] = fobj.Out(i)
         }
Добавление функции в корневой Objects позволят компилятору в дальнейшем находить их при использовании из контрактов.
         vm.Objects[key] = &ObjInfo{ObjExtFunc, data}
    }
}
